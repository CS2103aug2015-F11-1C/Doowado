# A0114519J
###### Doowado - Task Manager\Logic.cpp
``` cpp
	// Load configuration from file
	el::Configurations conf("Log.conf");
	// Reconfigure single logger
	el::Loggers::reconfigureLogger("default", conf);
	// Actually reconfigure all loggers instead
	el::Loggers::reconfigureAllLoggers(conf);
	// Now all the loggers will use configuration from file

```
###### Doowado - Task Manager\Parser.cpp
``` cpp
#include "Parser.h"
#include "ParserResult.h"

using namespace std;

Parser::Parser(){}

void Parser::resetAll(){
	_userDelimiter.clear();
	_userCommand.clear();
	_description.clear();
	_index.clear();
	_entryType.clear();
	_startYear.clear();
	_startMonth.clear();
	_startDay.clear();
	_startTime.clear();
	_endYear.clear();
	_endMonth.clear();
	_endDay.clear();
	_endTime.clear();
}

void Parser::resetDateAndTime() {
	_startYear.clear();
	_startMonth.clear();
	_startDay.clear();
	_startTime.clear();

	_endYear.clear();
	_endMonth.clear();
	_endDay.clear();
	_endTime.clear();
}

string Parser::removeExtraSpacePadding(string input){
	size_t start = input.find_first_not_of(SPACE);
	size_t end = input.find_last_not_of(SPACE);

	if (start != string::npos) {
		return input.substr(start, (end - start + 1));
	}else {		
		return "";
	}
}

string Parser::removeQuotations(string input){
	size_t start = input.find_first_not_of(QUOTATION_MARK);
	size_t end = input.find_last_not_of(QUOTATION_MARK);

	if (start != string::npos) {
		return input.substr(start, (end - start + 1));
	}
	else {
		return "";
	}
}

void Parser::setCommand(string& input) {
	size_t spacePos = input.find_first_of(SPACE);

	if (spacePos == string::npos) {
		_userCommand = convertStringTolowerCase(input);
		input = "";
	}
	else {
		_userCommand = convertStringTolowerCase(input.substr(0, spacePos));
		input = input.substr(spacePos + 1);
		input = removeExtraSpacePadding(input);
	}
}

void Parser::setDescription(string input){
	size_t delimiterPos;
	string invalidDateTimeInput;
	size_t quotationPos;


	if (!input.empty()) {
		quotationPos = input.find_last_of(QUOTATION_MARK);
		invalidDateTimeInput = input.substr(quotationPos + 1);

		if (quotationPos != string::npos && !invalidDateTimeInput.empty()) {
			resetAll();
			throw std::out_of_range(ERROR_INVALID_DATE_TIME_INPUT);
		}else {
			input = input.substr(0, quotationPos);
		}

		delimiterPos = input.find_first_of(MULTIPLE_DESCRIPTION_KEYWORDS_DELIMITER);
		if (delimiterPos != string::npos) {
			while (delimiterPos != string::npos) {
				string temp = input.substr(0, delimiterPos);
				temp = removeExtraSpacePadding(temp);
				if (!temp.empty()) {
					_description.push_back(temp);
				}
				
				if (delimiterPos + 1 == string::npos) {
					input = "";
					break;
				}

				input = input.substr(delimiterPos + 1);
				delimiterPos = input.find_first_of(MULTIPLE_DESCRIPTION_KEYWORDS_DELIMITER);
			}
			if (!input.empty()) {
				input = removeExtraSpacePadding(input);
				_description.push_back(input);
			}
		}else {
			_description.push_back(input);
		}	
	}
}

void Parser::setIndex(string& input){
	input = removeQuotations(input);
	size_t spacePos = input.find_first_of(SPACE);

	if (!input.empty()) {
		if (spacePos != string::npos) {
			string entryAndIndex = input.substr(0, spacePos);
			if (isIndexVaild(entryAndIndex)) {
				string entryType = entryAndIndex.substr(0, 1);
				entryType = convertStringTolowerCase(entryType);
				int indexInt = convertStringToInt(entryAndIndex.substr(1));
				_entryType.push_back(entryType);
				_index.push_back(indexInt);
				input = input.substr(spacePos + 1);
				input = removeExtraSpacePadding(input);
			}
		}else {
			if (isIndexVaild(input)) {
				string entryType = input.substr(0, 1);
				entryType = convertStringTolowerCase(entryType);
				int indexInt = convertStringToInt(input.substr(1));
				_entryType.push_back(entryType);
				_index.push_back(indexInt);
				input = "";
			}
		}
	}
}

bool Parser::isIndexVaild(string input){
	input = convertStringTolowerCase(input);

	string index = input.substr(1);
	int indexInt = convertStringToInt(index);
	string entryType = input.substr(0, 1);

	if ((entryType == "t" || entryType == "e") && indexInt != -1) {
		return true;
	}else {
		return false;
	}
}

void Parser::setDateAndTime(string& input){
	size_t delimiterPos;
	string dateAndTime;
	size_t spacePos;
	vector<string> dateAndTimeFragment;

	delimiterPos = findDateDelimiterPos(input);

	if (delimiterPos != string::npos) {
		dateAndTime = input.substr(delimiterPos);
		spacePos = dateAndTime.find_first_of(SPACE);
		dateAndTime = dateAndTime.substr(spacePos + 1);

		dateAndTime = convertStringTolowerCase(dateAndTime);
		dateAndTimeFragment = fragmentizeString(dateAndTime);

		dateSetter(dateAndTimeFragment);
		timeSetter(dateAndTimeFragment);

		//to remove the date and time keywords form the user input string
		input = input.substr(0, delimiterPos);
		input = removeExtraSpacePadding(input);

	}else if (input.find_first_of(SPACE) == string::npos) {
		dateAndTime = input;
		dateAndTime = convertStringTolowerCase(dateAndTime);

		if ((dateAndTime.find_first_not_of(NUMBER_AND_MULTIPLE_DELIMITER) != string::npos) && (isDateOrTimeKeywordValid(dateAndTime))) {
			dateAndTimeFragment = fragmentizeString(dateAndTime);

			dateSetter(dateAndTimeFragment);
			timeSetter(dateAndTimeFragment);

			input = "";
		}
	}else {
		resetDateAndTime();
	}
}

void Parser::dateSetter(vector<string>& input){
	int toPos=-1;
	bool foundTo = false;
	bool foundStartDate = false;
	bool foundEndDate = false;
	vector<int> markDatePos;

	for (int i = 0; i < input.size(); i++) {
		if (input[i] == START_END_DATE_DELIMITER) {
			toPos = i;
			foundTo = true;
			break;
		}
	}

	if (foundTo) {
		//set start date and end date
		vector<int> startYearMonthDay;
		for (int j = 0; j < toPos; j++) {
			startYearMonthDay = extractYearMonthDay(input[j]);
			if (!startYearMonthDay.empty()) {
				//copy day month and year
				markDatePos.push_back(j);
				_startYear.push_back(startYearMonthDay[0]);
				_startMonth.push_back(startYearMonthDay[1]);
				_startDay.push_back(startYearMonthDay[2]);
				foundStartDate = true;
				break;
			}
		}

		vector<int> endYearMonthDay;
		for (int k = toPos + 1; k < input.size(); k++) {
			endYearMonthDay = extractYearMonthDay(input[k]);
			if (!endYearMonthDay.empty()) {
				markDatePos.push_back(k);
				_endYear.push_back(endYearMonthDay[0]);
				_endMonth.push_back(endYearMonthDay[1]);
				_endDay.push_back(endYearMonthDay[2]);
				foundEndDate = true;
				break;
			}
		}

		//if the end time is not found or invaild, the end time will be set to start time!
		if ((endYearMonthDay.empty()) && (foundStartDate==true)) {
			_endYear.push_back(_startYear.back());
			_endMonth.push_back(_startMonth.back());
			_endDay.push_back(_startDay.back());
		}

		for (int z = 0; z < markDatePos.size(); z++) {
			input.erase(input.begin() + (markDatePos[z] - z));
		}

	}else {
		//set end date only
		vector<int> endYearMonthDay;
		for (int z = 0; z < input.size(); z++) {
			endYearMonthDay = extractYearMonthDay(input[z]);
			if (!endYearMonthDay.empty()) {
				if (_userDelimiter == "start" || _userDelimiter == "st") {
					markDatePos.push_back(z);
					_startYear.push_back(endYearMonthDay[0]);
					_startMonth.push_back(endYearMonthDay[1]);
					_startDay.push_back(endYearMonthDay[2]);
					break;
				}
				else {
					markDatePos.push_back(z);
					_endYear.push_back(endYearMonthDay[0]);
					_endMonth.push_back(endYearMonthDay[1]);
					_endDay.push_back(endYearMonthDay[2]);
					break;
				}
			}
		}

		for (int z = 0; z < markDatePos.size(); z++) {
			input.erase(input.begin() + (markDatePos[z] - z));
		}
	}
}

vector<int> Parser::extractYearMonthDay(string input){
	vector<int> output;
	vector<string> yearMonthDay;

	size_t dateSpliterPos = input.find_last_of(DATE_SPLITER);
	while (dateSpliterPos != string::npos) {
		string temp = input.substr(dateSpliterPos + 1);
		input = input.substr(0, dateSpliterPos);
		yearMonthDay.push_back(temp);
		dateSpliterPos = input.find_last_of(DATE_SPLITER);
	}
	//take in the last fragment of the string
	string day = input;
	yearMonthDay.push_back(day);

	if (yearMonthDay.size() == 3) {
		//v[0]year v[1}month v[2]day
		int temp;
		temp = isYearValid(yearMonthDay[0]);
		if (temp != -1) {
			output.push_back(temp);
			temp = isMonthValid(yearMonthDay[1]);
			if (temp != -1) {
				output.push_back(temp);
				temp = isDayValid(output[0], output[1], yearMonthDay[2]);
				if (temp != -1) {
					output.push_back(temp);
					return output;
				}else {
					output.clear();
					resetAll();
					throw std::out_of_range(ERROR_INVALID_DAY);
					return output;
				}
			}else {
				output.clear();
				resetAll();
				throw std::out_of_range(ERROR_INVALID_MONTH);
				return output;
			}
		}else {
			output.clear();
			resetAll();
			throw std::out_of_range(ERROR_INVALID_YEAR);
			return output;
		}
	}else if (yearMonthDay.size() == 2) {
		//v[0]month v[1]day
		int temp;
		temp = isMonthValid(yearMonthDay[0]);
		if (temp != -1) {
			vector<int> time = currentTime();
			//get the year from system, set the year as current year
			output.push_back(time[0]);		
			output.push_back(temp);
			temp = isDayValid(output[0], output[1], yearMonthDay[1]);
			if (temp != -1) {
				output.push_back(temp);
				return output;
			}else {
				output.clear();
				resetAll();
				throw std::out_of_range(ERROR_INVALID_DAY);
				return output;
			}
		}else {
			output.clear();
			resetAll();
			throw std::out_of_range(ERROR_INVALID_MONTH);
			return output;
		}
	}else if (yearMonthDay.size() == 1) {
		//v[0] such as fri, tmr, monday
		if (convertStringWeekdayToInt(yearMonthDay[0]) != -1) {
			output = calculateWeekdayToNearestDay(yearMonthDay[0]);
			return output;
		}else {
			output.clear();
			return output;
		}
	}else {
		output.clear();
		resetAll();
		throw std::out_of_range(ERROR_INVALID_DATE_TIME_INPUT);
		return output;
	}
}

vector<int> Parser::calculateWeekdayToNearestDay(string input){
	vector<int> output;
	vector<int> timeNow = currentTime();
	int currentYear = timeNow[0];
	int currentMonth = timeNow[1];
	int currentDay = timeNow[2];
	int currentWeekday = timeNow[3];
	int userInputWeekday = convertStringWeekdayToInt(input);

	if (userInputWeekday >= 1 && userInputWeekday <= 7) {
		if (userInputWeekday >= currentWeekday) {
			currentDay = currentDay + userInputWeekday - currentWeekday;
		}
		else {
			currentDay = currentDay + userInputWeekday - currentWeekday + 7;
		}
	}else if (userInputWeekday == 8) {
		currentDay = currentDay;
	}else if (userInputWeekday == 9) {
		currentDay = currentDay + 1;
	//for the nullify the date case
	}else if (userInputWeekday == 11) {
		currentYear = -1;
		currentMonth = -1;
		currentDay = -1;
		output.push_back(currentYear);
		output.push_back(currentMonth);
		output.push_back(currentDay);
		return output;
	}

	solveDayOverFlow(currentYear, currentMonth, currentDay);

	output.push_back(currentYear);
	output.push_back(currentMonth);
	output.push_back(currentDay);
	return output;
}

void Parser::solveDayOverFlow(int & year, int & month, int & day){
	if ((day > 31) && (month == 12)) {
		day = day - 31;
		month = 1;
		year++;
	}

	if (day > numberOfDaysInMonth(year, month)) {
		day = day - numberOfDaysInMonth(year, month);
		month++;
	}
}

int Parser::numberOfDaysInMonth(int year, int month) {
	if ((month < 1) || (month > 12)) {
		return -1;
	}
	else if ((month == 4) || (month == 6) || (month == 9) || (month == 11)) {
		return 30;
	}
	else if (month == 2 && isLeapYear(year)) {
		return 29;
	}
	else if (month == 2 && !isLeapYear(year)) {
		return 28;
	}
	else {
		return 31;
	}
}

bool Parser::isLeapYear(int input){
	return (((input % 400) == 0) || (input % 4) == 0) && (((input % 100) != 0));
}

int Parser::convertStringWeekdayToInt(string input){
	int dateIdx;
	int dateInNumber;

	for (int i = DATE_KEYWORD_START_POS; i < DDATE_KEYWORDS_END_POS; i++) {
		if (DATE_KEYWORDS[i] == input) {
			dateIdx = i;
			break;
		}else {
			dateIdx = DATE_NOT_FOUND;
		}
	}

	switch (dateIdx) {
	case 24:
	case 25:
		dateInNumber = 1;
		break;
	case 26:
	case 27:
		dateInNumber = 2;

		break;
	case 28:
	case 29:
		dateInNumber = 3;
		break;
	case 30:
	case 31:
		dateInNumber = 4;
		break;
	case 32:
	case 33:
		dateInNumber = 5;
		break;
	case 34:
	case 35:
		dateInNumber = 6;
		break;
	case 36:
	case 37:
		dateInNumber = 7;
		break;
	case 38:
		dateInNumber = 8;
		break;
	case 39:
	case 40:
		dateInNumber = 9;
		break;
	case 41:
		dateInNumber = 11;
		break;
	case 42:
		dateInNumber = -1;
		break;
	}

	return dateInNumber;
}

int Parser::convertStringMonthToInt(string input){
	int monthIdx;
	int monthInNumber;
	int const NOTFOUND = 24;

	for (int i = MONTH_KEYWORD_START_POS; i < MONTH_KEYWORD_END_POS; i++) {
		if (DATE_KEYWORDS[i] == input) {
			monthIdx = i;
			break;
		}
		else {
			monthIdx = NOTFOUND;
		}
	}

	switch (monthIdx) {
	case 0:
	case 1:
		monthInNumber = 1;
		break;
	case 2:
	case 3:
		monthInNumber = 2;
		break;
	case 4:
	case 5:
		monthInNumber = 3;
		break;
	case 6:
	case 7:
		monthInNumber = 4;
		break;
	case 8:
	case 9:
		monthInNumber = 5;
		break;
	case 10:
	case 11:
		monthInNumber = 6;
		break;
	case 12:
	case 13:
		monthInNumber = 7;
		break;
	case 14:
	case 15:
		monthInNumber = 8;
		break;
	case 16:
	case 17:
		monthInNumber = 9;
		break;
	case 18:
	case 19:
		monthInNumber = 10;
		break;
	case 20:
	case 21:
		monthInNumber = 11;
		break;
	case 22:
	case 23:
		monthInNumber = 12;
		break;
	case 24:
		monthInNumber = -1;
		break;
	}

	return monthInNumber;
}

int Parser::isDayValid(int year, int month, string day){
	int intDay;
	intDay = convertStringToInt(day);
	
	if ((intDay >= 1) && (intDay <= numberOfDaysInMonth(year, month))) {
		return intDay;
	}else {
		return intDay = -1;
	}
}

int Parser::isMonthValid(string input){
	int month;

	month = convertStringToInt(input);
	if (month <= 12 && month >= 1) {
		return month;
	}else {
		month = convertStringMonthToInt(input);
		return month;
	}
}

int Parser::isYearValid(string input){
	int year;

	year = convertStringToInt(input);
	if (year <= 2999 && year >= 2000) {
		return year;
	}else {
		return year = -1;
	}
}

void Parser::timeSetter(vector<string>& input){
	int toPos = -1;
	bool foundTo = false;
	bool foundStartTime = false;
	bool foundEndTime = false;
	vector<int> markTimePos;

	for (int i = 0; i < input.size(); i++) {
		if (input[i] == START_END_TIME_DELIMITER) {
			toPos = i;
			foundTo = true;
			break;
		}
	}

	if (foundTo) {
		//set start time and end time
		int startTime;
		for (int j = 0; j < toPos; j++) {
			startTime = extractTime(input[j]);
			if (startTime != -1) {
				markTimePos.push_back(j);
				_startTime.push_back(startTime);
				foundStartTime = true;
				break;
			}
		}

		int endTime;
		for (int k = toPos + 1; k < input.size(); k++) {
			endTime = extractTime(input[k]);
			if (endTime != -1) {
				markTimePos.push_back(k);
				_endTime.push_back(endTime);
				foundEndTime = true;
				break;
			}
		}

		for (int z = 0; z < markTimePos.size(); z++) {
			input.erase(input.begin() + (markTimePos[z] - z));
		}

	}else {
		//set end time only
		int endTime;
		for (int z = 0; z < input.size(); z++) {
			endTime = extractTime(input[z]);
			if (endTime != -1) {
				if (_userDelimiter == "start" || _userDelimiter == "st") {
					markTimePos.push_back(z);
					_startTime.push_back(endTime);
					break;
				}else {
					markTimePos.push_back(z);
					_endTime.push_back(endTime);
					break;
				}
			}
		}

		for (int z = 0; z < markTimePos.size(); z++) {
			input.erase(input.begin() + (markTimePos[z] - z));
		}
	}
}

int Parser::extractTime(string input){
	string hour;
	int hourInt;
	string minute;
	int minuteInt;
	int timeInt;

	size_t dateSpliterPos = input.find_last_of(DATE_SPLITER);
	if (dateSpliterPos == string::npos) {
		if (input.size() <= 4 && input.size() > 0) {
			if (input.size() == 4) {
				hour = input.substr(0, 2);
				minute = input.substr(2, 2);
				hourInt = convertStringToInt(hour);
				minuteInt = convertStringToInt(minute);
				if (isTimeValid(hourInt, minuteInt)) {
					timeInt = hourInt * 100 + minuteInt;
					return timeInt;
				}else {
					resetAll();
					throw std::out_of_range(ERROR_INVALID_TIME_INPUT);
					return timeInt = -1;
				}
			}
			else if (input.size() == 3) {
				hour = input.substr(0, 1);
				minute = input.substr(1, 2);
				hourInt = convertStringToInt(hour);
				minuteInt = convertStringToInt(minute);
				if (isTimeValid(hourInt, minuteInt)) {
					timeInt = hourInt * 100 + minuteInt;
					return timeInt;
				}else {
					resetAll();
					throw std::out_of_range(ERROR_INVALID_TIME_INPUT);
					return timeInt = -1;
				}
			}
			else if (input.size() == 2 || input.size() == 1) {
				hour = input;
				hourInt = convertStringToInt(hour);
				minuteInt = 0;
				if (isTimeValid(hourInt, minuteInt)) {
					timeInt = hourInt * 100 + minuteInt;
					return timeInt;
				}else {
					resetAll();
					throw std::out_of_range(ERROR_INVALID_TIME_INPUT);
					return timeInt = -1;
				}
			}else {
				return timeInt = -1;
			}
		}else {
			return timeInt = -1;
		}
	}else {
		return timeInt = -1;
	}
}

bool Parser::isTimeValid(int hour, int minute){
	if ((hour >= 0 && hour <= 23) && (minute >= 0 && minute <= 59)) {
		return true;
	}else {
		return false;
	}
}

vector<string> Parser::fragmentizeString(string input){
	vector<string> dateAndTime;
	string fragment;

	istringstream in(input);
	while (in >> fragment) {
		dateAndTime.push_back(fragment);
	}
	return dateAndTime;
}

size_t Parser::findDateDelimiterPos(string input) {
	string delimiter = "";
	size_t foundDelimiter;
	size_t finalDelimiter = 0;
	string lowerCaseInput;
	string temp;
	bool lastDelimiter;
	size_t occurredInMiddleOfAWord = string::npos;

	lowerCaseInput = convertStringTolowerCase(input);
	temp = lowerCaseInput;

	do {
		for (int i = 0; i < DATE_DELIMITER_SIZE; i++) {
			foundDelimiter = temp.rfind(DATE_DELIMITER[i]);
			if (foundDelimiter != string::npos) {
				if ((foundDelimiter == 0) && (temp.substr(foundDelimiter, temp.find_first_of(SPACE, foundDelimiter) - foundDelimiter) == DATE_DELIMITER[i])) {
					occurredInMiddleOfAWord = string::npos;
					delimiter = DATE_DELIMITER[i];
					finalDelimiter = foundDelimiter;
				}else if (foundDelimiter > finalDelimiter) {
					if (temp.substr(foundDelimiter, 1) == DATE_DELIMITER[i]) {
						occurredInMiddleOfAWord = string::npos;
						delimiter = DATE_DELIMITER[i];
						finalDelimiter = foundDelimiter;
					}else if ((temp.substr(foundDelimiter - 1, 1) == SPACE) && (temp.substr(foundDelimiter, temp.find_first_of(SPACE, foundDelimiter) - foundDelimiter) == DATE_DELIMITER[i])) {
						occurredInMiddleOfAWord = string::npos;
						delimiter = DATE_DELIMITER[i];
						finalDelimiter = foundDelimiter;
					}else {
						occurredInMiddleOfAWord = foundDelimiter;
					}
				}else {
					occurredInMiddleOfAWord = string::npos;
				}
			}else {
				occurredInMiddleOfAWord = string::npos;
			}
		}
		if (occurredInMiddleOfAWord != string::npos) {
			temp = temp.substr(0, occurredInMiddleOfAWord);
			lastDelimiter = false;
		}else {
			lastDelimiter = true;
		}
	} while (!lastDelimiter);


	if (finalDelimiter != string::npos && delimiter != "") {
		if (!isDateDelimiterValid(lowerCaseInput, finalDelimiter)) {
			return string::npos;
		}else {
			//record which delimeter the user used.
			_userDelimiter = delimiter;
			return finalDelimiter;
		}
	}else {
		return string::npos;
	}
}

bool Parser::isDateDelimiterValid(string input, size_t pos){
	string temp;
	string keyWord;
	size_t spacePos;
	bool isValid = true;
	
	temp = input.substr(pos);
	spacePos = temp.find_first_of(SPACE);
	if (spacePos == string::npos) {
		return false;
	}else {
		temp = temp.substr(spacePos + 1);
		istringstream in(temp);
		while (in >> keyWord) {
			if (!isDateOrTimeKeywordValid(keyWord)) {
				isValid = false;
				break;
			}
		}
	}
	return isValid;
}

bool Parser::isDateOrTimeKeywordValid(string input){
	int temp;
	temp = convertStringToInt(input);

	if (temp >= 0) {
		return true;
	}else {
		for (int i = 0; i < DATE_TIME_KEYWORDS_SIZE; i++) {
			if (DATE_KEYWORDS[i] == input) {
				return true;
			}
		}
	}
	return false;
}

int Parser::convertStringToInt(string input){
	stringstream convetor;
	int number;

	convetor << input;
	convetor >> number;

	if (convetor.fail()) {
		return number = -1;	
	}else {
		return number;
	}
}

string Parser::convertStringTolowerCase(string input){
	transform(input.begin(), input.end(), input.begin(), ::tolower);
	return input;
}

vector<int> Parser::currentTime(){
	string year;
	string month;
	string day;
	string weekday;
	vector<int> timeOutput;

	string timeNow;
	time_t rawtime;
	time(&rawtime);
	struct tm timeinfo;
	localtime_s(&timeinfo, &rawtime);
	char buffer[128];
	strftime(buffer, 128, "%Y%m%d%A", &timeinfo);
	timeNow = buffer;

	year = timeNow.substr(0, 4);
	month= timeNow.substr(4, 2);
	day= timeNow.substr(6, 2);
	weekday = timeNow.substr(8);

	timeOutput.push_back(convertStringToInt(year));
	timeOutput.push_back(convertStringToInt(month));
	timeOutput.push_back(convertStringToInt(day));
	weekday = convertStringTolowerCase(weekday);
	timeOutput.push_back(convertStringWeekdayToInt(weekday));

	return timeOutput;
}

ParserResult Parser::parse(string input){
	vector<string> output;
	ParserResult parserResult;

	try {
		string userInput = input;
		LOG(INFO) << "Parser-Initial input:" << userInput;
		if (userInput.empty()) {
			resetAll();
			throw std::out_of_range(ERROR_EMPTY_INPUT);
		}

		userInput = removeExtraSpacePadding(userInput);
		setCommand(userInput);
		LOG(INFO) << "Parser-After setCommand:" << userInput;
		setDateAndTime(userInput);
		LOG(INFO) << "Parser-After setDateAndTime:" << userInput;
		setIndex(userInput);
		LOG(INFO) << "Parser-After setIndex:" << userInput;
		setDescription(userInput);
		LOG(INFO) << "Parser-After setDescription:" << userInput;
	}

	catch (const out_of_range& error) {
		LOG(INFO) << "Parser-Exception:" << error.what();
		resetAll();
		throw std::out_of_range(error.what());
	}

	parserResult.setUserCommand(_userCommand);
	parserResult.setDescription(_description);
	parserResult.setIndex(_index);
	parserResult.setEntryType(_entryType);
	parserResult.setStartDate(_startYear, _startMonth, _startDay);
	parserResult.setStartTime(_startTime);
	parserResult.setEndDate(_endYear, _endMonth, _endDay);
	parserResult.setEndTime(_endTime);
	resetAll();

	return parserResult;
}
```
###### Doowado - Task Manager\Parser.h
``` h
#ifndef PARSER_H
#define PARSER_H

#include "ParserResult.h"
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <time.h> 
#include <exception>
#include "easylogging++.h"

using namespace std;

//CONSTANTS
int const DATE_TIME_KEYWORDS_SIZE = 44;
int const MONTH_KEYWORD_START_POS = 0;
int const MONTH_KEYWORD_END_POS = 24;
int const DATE_KEYWORD_START_POS = 24;
int const DDATE_KEYWORDS_END_POS = 42;
int const DATE_NOT_FOUND = 42;

string const DATE_KEYWORDS[] = { "january", "jan", "february", "feb", "march", "mar", "april", "apr",
"may", "may", "june", "jun", "july", "jul", "august", "aug", "september", "sep", "october", "oct",
"november", "nov", "december", "dec", "monday", "mon", "tuesday", "tue", "wednesday", "wed", "thursday",
"thu", "friday", "fri", "saturday", "sat", "sunday", "sun", "today", "tomorrow", "tmr","null", "to" };

string const DATE_DELIMITER[] = { "\"", "by","at","start","end","from","ed","st","fr","on" };
int const DATE_DELIMITER_SIZE = 10;
string const DATE_SPLITER = "./";
string const MULTIPLE_DESCRIPTION_KEYWORDS_DELIMITER = "|";
string const START_END_DATE_DELIMITER = "to";
string const START_END_TIME_DELIMITER = "to";
string const SPACE = " ";
string const QUOTATION_MARK = "\"";
string const NUMBER_AND_MULTIPLE_DELIMITER = "0123456789|";

string const ERROR_EMPTY_INPUT = "Empty input";
string const ERROR_INVALID_DATE_TIME_INPUT = "Invalid date or time input";
string const ERROR_INVALID_YEAR = "Invalid year input";
string const ERROR_INVALID_MONTH = "Invalid month input";
string const ERROR_INVALID_DAY = "Invalid day input";
string const ERROR_INVALID_TIME_INPUT = "Invalid time input";

class Parser {

private:
	string _userDelimiter;

	//command & description
	string _userCommand;
	vector<string> _description;
	vector<int> _index;
	vector<string> _entryType;
	
	//start
	vector<int> _startYear;
	vector<int> _startMonth;
	vector<int> _startDay;
	vector<int> _startTime;

	//end
	vector<int> _endYear;
	vector<int> _endMonth;
	vector<int> _endDay;
	vector<int> _endTime;

public:
	Parser::Parser();

	void resetAll();

	void resetDateAndTime();

	//Take in full  user input string, remove the extra space padding.
	string removeExtraSpacePadding(string input);

	string removeQuotations(string input);

	//Take in full user input string.
	//Set and remove command from the user input string.
	void setCommand(string & input);

	//Take in the user input string without command, date & time keywords and entry type & index.
	//Throw exception of invalid date & time keywords if anything found after the last quotation mark.
	void setDescription(string input);

	//Take in the user input string without command and date & time keywords.
	//Set and remove entry type and index from the user input string.
	void setIndex(string & input);

	bool isIndexVaild(string input);

	//Take in the user input string without command.
	//Set and remove date & time keywords from the user input string.
	void setDateAndTime(string & input);

	//Take in fragmentized vector of string of date & time keywords
	//Find the date keywords and push to start date or end date accordingly, then remove the date found from the vector of string
	void dateSetter(vector<string> & input);

	//Input format 1. 17/10/2015 2. 17.oct 3. fri
	//Output format is in vector of year month and day, v[0]year v[1]month v[2]day
	//Throw exceptions if any of the year month or day is invalid
	vector<int> extractYearMonthDay(string input);

	//Input type fri,tue...,tmr,today
	//Output type v[0]year v[1}month v[2]day
	//If the input day have not passed in current week, the function will return the date accrodingly
	//If the input day have passed in current week, the function will return next week's date accordingly
	vector<int> calculateWeekdayToNearestDay(string input);

	void solveDayOverFlow(int& year, int& month, int& day);

//	void solveNextWeekday(int& year, int& month, int& day);

	int numberOfDaysInMonth(int year, int month);

	bool isLeapYear(int input);

	int convertStringWeekdayToInt(string input);

	int convertStringMonthToInt(string input);

	//Return the day in integer format, return -1 if the input is not a day.
	int isDayValid(int year, int month, string day);

	//Return the month in integer format, return -1 if the input is not a month.
	int isMonthValid(string input);

	//Return the year in integer format, return -1 if the input is not a year.
	int isYearValid(string input);

	//Take in fragmentized vector of string of date & time keywords
	//Find the time keywords and push to start time or end time accordingly, then remove the time found from the vector of string
	void timeSetter(vector<string> & input);

	//Input format is 24hr, e.g. 0830.830,1240,2359
	//Output 0 means 00:00, 1 means 00:01, 59 means 00:59, 100 means 01:00
	int extractTime(string input);

	bool isTimeValid(int hour, int minute);

	//Input a string the function will trim it to each single words, store them in a vector and return the vector.
	vector<string> fragmentizeString(string input);

	//Take in full user input.
	//Return the position if a valid date delimiter is found, return string::npos if not found.
	size_t findDateDelimiterPos(string input);

	//Check every keywords after the date delimiter.
	//If all the keywords after date delimiter are date or time keywords, return true. Otherwise return false.
	bool isDateDelimiterValid(string input, size_t pos);

	//Check the validity of a date or time keyword.
	bool isDateOrTimeKeywordValid(string input);

	//Return -1 if the string is not a number, otherwise return the number in integer format.
	int convertStringToInt(string input);

	string convertStringTolowerCase(string input);

	//Return the current system time in a vector of integer format
	//v[0]year v[1]month v[2]day v[3]weekday in integer format
	vector<int> currentTime();

	//Parser class API
	ParserResult parse(string input);
};
#endif
```
###### Doowado - Task Manager\ParserResult.cpp
``` cpp
#include "ParserResult.h"

ParserResult::ParserResult(){
	//command & description
	_userCommand = "";
	_description.clear();
	_index.clear();
	_entryType.clear();

	//date
	_startDate.clear();
	_endDate.clear();

	//time
	_startTime.clear();
	_endTime.clear();
}

void ParserResult::resetAll(){
	_userCommand = "";
	_description.clear();
	_index.clear();
	_entryType.clear();
	_startDate.clear();
	_endDate.clear();
	_startTime.clear();
	_endTime.clear();
}

void ParserResult::setUserCommand(string userCommand){
	_userCommand = userCommand;
}

void ParserResult::setDescription(vector<string> description){
	_description = description;
}

void ParserResult::setIndex(vector<int> index){
	_index = index;
}

void ParserResult::setEntryType(vector<string> entryType){
	_entryType = entryType;
}

void ParserResult::setStartDate(vector<int> startYear, vector<int> startMonth, vector<int> startDay){

	if (!startYear.empty() && !startMonth.empty() && !startDay.empty()) {
		for (int i = 0; i < startYear.size(); i++) {
			ostringstream out;
			if (startYear[i] == -1) {
				out << "null";
				_startDate.push_back(out.str());
			}else {
				out << startYear[i];
				if (startMonth[i] < 10) {
					out << "0" << startMonth[i];
				}else {
					out << startMonth[i];
				}

				if (startDay[i] < 10) {
					out << "0" << startDay[i];
				}else {
					out << startDay[i];
				}
				_startDate.push_back(out.str());
			}
		}
	}
}

void ParserResult::setEndDate(vector<int> endYear, vector<int> endMonth, vector<int> endDay){

	if (!endYear.empty() && !endMonth.empty() && !endDay.empty()) {
		for (int i = 0; i < endYear.size(); i++) {
			ostringstream out;
			if (endYear[i] == -1) {
				out << "null";
				_endDate.push_back(out.str());
			}else {
				out << endYear[i];
				if (endMonth[i] < 10) {
					out << "0" << endMonth[i];
				}else {
					out << endMonth[i];
				}

				if (endDay[i] < 10) {
					out << "0" << endDay[i];
				}else {
					out << endDay[i];
				}
				_endDate.push_back(out.str());
			}
		}
	}
}

void ParserResult::setStartTime(vector<int> startTime){
	
	if (!startTime.empty()) {
		for (int i = 0; i < startTime.size(); i++) {
			ostringstream out;
			if (startTime[i] < 1000) {
				out << "0" << startTime[i] / 100 << ":" << startTime[i] % 100 << ":00";
				_startTime.push_back(out.str());
			}else {
				out << startTime[i] / 100 << ":" << startTime[i] % 100 << ":00";
				_startTime.push_back(out.str());
			}
		}
	}
}

void ParserResult::setEndTime(vector<int> endTime){

	if (!endTime.empty()) {
		for (int i = 0; i < endTime.size(); i++) {
			ostringstream out;
			if (endTime[i] < 1000) {
				out << "0" << endTime[i] / 100 << ":" << endTime[i] % 100 << ":00";
				_endTime.push_back(out.str());
			}else {
				out << endTime[i] / 100 << ":" << endTime[i] % 100 << ":00";
				_endTime.push_back(out.str());
			}
		}
	}
}

string& ParserResult::getUserCommand(){
	return _userCommand;
}

vector<string>& ParserResult::getDescription(){
	return _description;
}

vector<int>& ParserResult::getIndex(){
	return _index;
}

vector<string>& ParserResult::getEntryType(){
	return _entryType;
}

vector<string>& ParserResult::getStartDate(){
	return _startDate;
}

vector<string>& ParserResult::getEndDate(){
	return _endDate;
}

vector<string>& ParserResult::getStartTime(){
	return _startTime;
}

vector<string>& ParserResult::getEndTime(){
	return _endTime;
}

ParserResult::~ParserResult(){
}
```
###### Doowado - Task Manager\ParserResult.h
``` h
#ifndef PARSER_RESULT_H
#define PARSER_RESULT_H

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>

using namespace std;

class ParserResult {
private:
	//command & description
	string _userCommand;
	vector<string> _description;
	vector<int> _index;
	vector<string> _entryType;

	//date
	vector<string> _startDate;
	vector<string> _endDate;

	//time
	vector<string> _startTime;
	vector<string> _endTime;

public:
	ParserResult::ParserResult();

	void resetAll();

	void setUserCommand(string userCommand);

	void setDescription(vector<string> description);

	void setIndex(vector<int> index);

	void setEntryType(vector<string> entryType);

	void setStartDate(vector<int> startYear, vector<int> startMonth, vector<int> startDay);

	void setEndDate(vector<int> endYear, vector<int> endMonth, vector<int> endDay);

	void setStartTime(vector<int> startTime);

	void setEndTime(vector<int> endTime);

	string& getUserCommand();

	vector<string>& getDescription();

	vector<int>& getIndex();

	vector<string>& getEntryType();

	vector<string>& getStartDate();

	vector<string>& getEndDate();

	vector<string>& getStartTime();

	vector<string>& getEndTime();
	
	~ParserResult();
};
#endif
```
###### ParserTest\ParserTest.cpp
``` cpp
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ParserTest{
	TEST_CLASS(ParserTest){
	public:
	
		//add floating task
		TEST_METHOD(parseTest1) {
			Parser parse;
			ParserResult output;
			string input = "add watch harry potter";
			string expectedCommand = "add";
			string expectedDescription = "watch harry potter";
			string expectedEntryType = "";
			int expectedIndex;
			string expectedStartDate = "";
			string expectedStartTime = "";
			string expectedEndDate = "";
			string expectedEndTime = "";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription);
		}

		//add deadline event
		TEST_METHOD(parseTest2) {
			Parser parse;
			ParserResult output;
			string input = "add complete the man on monday by 31.12.2015";
			string expectedCommand = "add";
			string expectedDescription = "complete the man on monday";
			string expectedEntryType = "";
			int expectedIndex;
			string expectedStartDate = "";
			string expectedStartTime = "";
			string expectedEndDate = "20151231";
			string expectedEndTime = "";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription);
			Assert::AreEqual(output.getEndDate()[0], expectedEndDate);
		}

		//add a task
		TEST_METHOD(parseTest3) {
			Parser parse;
			ParserResult output;
			string input = "add cs tutorial from 8/8/2015 1125 to 25/10/2015 1230";
			string expectedCommand = "add";
			string expectedDescription = "cs tutorial";
			string expectedEntryType = "";
			int expectedIndex;
			string expectedStartDate = "20150808";
			string expectedStartTime = "11:25:00";
			string expectedEndDate = "20151025";
			string expectedEndTime = "12:30:00";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription);
			Assert::AreEqual(output.getStartDate()[0], expectedStartDate);
			Assert::AreEqual(output.getStartTime()[0], expectedStartTime);
			Assert::AreEqual(output.getEndDate()[0], expectedEndDate);
			Assert::AreEqual(output.getEndTime()[0], expectedEndTime);
		}

		//add with quotation marks
		TEST_METHOD(parseTest4) {
			Parser parse;
			ParserResult output;
			string input = "   add    \"complete the man on monday\"    ";
			string expectedCommand = "add";
			string expectedDescription = "complete the man on monday";
			string expectedEntryType = "";
			int expectedIndex;
			string expectedStartDate = "";
			string expectedStartTime = "";
			string expectedEndDate = "";
			string expectedEndTime = "";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription);
		}

		//edit description only
		TEST_METHOD(parseTest5) {
			Parser parse;
			ParserResult output;
			string input = "edit T29 i will go to IBD";
			string expectedCommand = "edit";
			string expectedDescription = "i will go to IBD";
			string expectedEntryType = "t";
			int expectedIndex = 29;
			string expectedStartDate = "";
			string expectedStartTime = "";
			string expectedEndDate = "";
			string expectedEndTime = "";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription);
			Assert::AreEqual(output.getEntryType()[0], expectedEntryType);
			Assert::AreEqual(output.getIndex()[0], expectedIndex);
		}

		//edit starting time only
		TEST_METHOD(parseTest6) {
			Parser parse;
			ParserResult output;
			string input = "edit E29 st 8/aug/2015 0629";
			string expectedCommand = "edit";
			string expectedDescription = "";
			string expectedEntryType = "e";
			int expectedIndex = 29;
			string expectedStartDate = "20150808";
			string expectedStartTime = "06:29:00";
			string expectedEndDate = "";
			string expectedEndTime = "";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getEntryType()[0], expectedEntryType);
			Assert::AreEqual(output.getIndex()[0], expectedIndex);
			Assert::AreEqual(output.getStartDate()[0], expectedStartDate);
			Assert::AreEqual(output.getStartTime()[0], expectedStartTime);
		}

		//edit ending time only 
		TEST_METHOD(parseTest7) {
			Parser parse;
			ParserResult output;
			string input = "edit E29 ed 25/oct/2015 915";
			string expectedCommand = "edit";
			string expectedDescription = "";
			string expectedEntryType = "e";
			int expectedIndex = 29;
			string expectedStartDate = "";
			string expectedStartTime = "";
			string expectedEndDate = "20151025";
			string expectedEndTime = "09:15:00";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getEntryType()[0], expectedEntryType);
			Assert::AreEqual(output.getIndex()[0], expectedIndex);
			Assert::AreEqual(output.getEndDate()[0], expectedEndDate);
			Assert::AreEqual(output.getEndTime()[0], expectedEndTime);
		}

		//edit both starting and ending time to null
		TEST_METHOD(parseTest8) {
			Parser parse;
			ParserResult output;
			string input = "edit t5 from null to null";
			string expectedCommand = "edit";
			string expectedDescription = "";
			string expectedEntryType = "t";
			int expectedIndex = 5;
			string expectedStartDate = "null";
			string expectedStartTime = "";
			string expectedEndDate = "null";
			string expectedEndTime = "";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getEntryType()[0], expectedEntryType);
			Assert::AreEqual(output.getIndex()[0], expectedIndex);
			Assert::AreEqual(output.getStartDate()[0], expectedStartDate);
			Assert::AreEqual(output.getEndDate()[0], expectedEndDate);
		}

		//search for multiple keywords
		TEST_METHOD(parseTest9) {
			Parser parse;
			ParserResult output;
			string input = "search i|want| to|||go  |||   home";
			string expectedCommand = "search";
			string expectedDescription1 = "i";
			string expectedDescription2 = "want";
			string expectedDescription3 = "to";
			string expectedDescription4 = "go";
			string expectedDescription5 = "home";
	
			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription1);
			Assert::AreEqual(output.getDescription()[1], expectedDescription2);
			Assert::AreEqual(output.getDescription()[2], expectedDescription3);
			Assert::AreEqual(output.getDescription()[3], expectedDescription4);
			Assert::AreEqual(output.getDescription()[4], expectedDescription5);
		}

		//show for a range of date
		TEST_METHOD(parseTest10) {
			Parser parse;
			ParserResult output;
			string input = "show from 8/8/2015 1958 to 25/10/2015 2101";
			string expectedCommand = "show";
			string expectedDescription = "";
			string expectedEntryType = "";
			int expectedIndex = 5;
			string expectedStartDate = "20150808";
			string expectedStartTime = "19:58:00";
			string expectedEndDate = "20151025";
			string expectedEndTime = "21:1:00";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getStartDate()[0], expectedStartDate);
			Assert::AreEqual(output.getStartTime()[0], expectedStartTime);
			Assert::AreEqual(output.getEndDate()[0], expectedEndDate);
			Assert::AreEqual(output.getEndTime()[0], expectedEndTime);
		}

		//add a number only
		TEST_METHOD(parseTest11) {
			Parser parse;
			ParserResult output;
			string input = "add 629";
			string expectedCommand = "add";
			string expectedDescription1 = "629";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription1);
		}

		TEST_METHOD(parseTest12) {
			Parser parse;
			ParserResult output;
			string input = "show 1.jan.2015";
			string expectedCommand = "show";
			string expectedDescription = "";
			string expectedEntryType = "";
			int expectedIndex;
			string expectedStartDate = "";
			string expectedStartTime = "";
			string expectedEndDate = "20150101";
			string expectedEndTime = "";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getEndDate()[0], expectedEndDate);
		}

		TEST_METHOD(parseTest13) {
			Parser parse;
			ParserResult output;
			string input = "search 11|22";
			string expectedCommand = "search";
			string expectedDescription1 = "11";
			string expectedDescription2 = "22";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription1);
			Assert::AreEqual(output.getDescription()[1], expectedDescription2);
		}

		TEST_METHOD(parseTest14) {
			Parser parse;
			ParserResult output;
			string input = "search 11 ||22";
			string expectedCommand = "search";
			string expectedDescription1 = "11";
			string expectedDescription2 = "22";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription1);
			Assert::AreEqual(output.getDescription()[1], expectedDescription2);
		}

		TEST_METHOD(parseTest15) {
			Parser parse;
			ParserResult output;
			string input = "search i|want";
			string expectedCommand = "search";
			string expectedDescription1 = "i";
			string expectedDescription2 = "want";

			output = parse.parse(input);

			Assert::AreEqual(output.getUserCommand(), expectedCommand);
			Assert::AreEqual(output.getDescription()[0], expectedDescription1);
			Assert::AreEqual(output.getDescription()[1], expectedDescription2);
		}

		TEST_METHOD(removeExtraSpacePadding) {
			Parser parse;
			string input1 = "add finish ie4210 due by tmr";
			string expected1 = "add finish ie4210 due by tmr";
			string input2 = "      add finish ie4210 due by tmr        ";
			string expected2 = "add finish ie4210 due by tmr";

			Assert::AreEqual(parse.removeExtraSpacePadding(input1), expected1);
			Assert::AreEqual(parse.removeExtraSpacePadding(input2), expected2);
		}

		TEST_METHOD(isIndexVaild) {
			Parser parse;
			string input1 = "t1";
			string input2 = "T1";
			string input3 = "e1";
			string input4 = "E1";
			string input5 = "f1";

			Assert::IsTrue(parse.isIndexVaild(input1));
			Assert::IsTrue(parse.isIndexVaild(input2));
			Assert::IsTrue(parse.isIndexVaild(input3));
			Assert::IsTrue(parse.isIndexVaild(input4));
			Assert::IsFalse(parse.isIndexVaild(input5));
		}

		//valid input with delimiter "/"
		TEST_METHOD(extractYearMonthDayTest1) {
			Parser parse;
			string input = "12/10/2015";
			vector<int> result;
			int expectedYear = 2015;
			int expectedMonth = 10;
			int expectedDay = 12;

			result = parse.extractYearMonthDay(input);
			Assert::AreEqual(result[0], expectedYear);
			Assert::AreEqual(result[1], expectedMonth);
			Assert::AreEqual(result[2], expectedDay);
		}

		//valid input with delimiter "."
		TEST_METHOD(extractYearMonthDayTest2) {
			Parser parse;
			string input = "12.10.2015";
			vector<int> result;
			int expectedYear = 2015;
			int expectedMonth = 10;
			int expectedDay = 12;

			result = parse.extractYearMonthDay(input);
			Assert::AreEqual(result[0], expectedYear);
			Assert::AreEqual(result[1], expectedMonth);
			Assert::AreEqual(result[2], expectedDay);
		}

		//valid input with date and month only case 1
		TEST_METHOD(extractYearMonthDayTest3) {
			Parser parse;
			string input = "12/10";
			vector<int> result;
			int expectedYear = 2015;
			int expectedMonth = 10;
			int expectedDay = 12;

			result = parse.extractYearMonthDay(input);
			Assert::AreEqual(result[0], expectedYear);
			Assert::AreEqual(result[1], expectedMonth);
			Assert::AreEqual(result[2], expectedDay);
		}

		//valid input with date and month only case 2
		TEST_METHOD(extractYearMonthDayTest4) {
			Parser parse;
			string input = "12.oct";
			vector<int> result;
			int expectedYear = 2015;
			int expectedMonth = 10;
			int expectedDay = 12;

			result = parse.extractYearMonthDay(input);
			Assert::AreEqual(result[0], expectedYear);
			Assert::AreEqual(result[1], expectedMonth);
			Assert::AreEqual(result[2], expectedDay);
		}

		//valid input with day only
		TEST_METHOD(extractYearMonthDayTest5) {
			Parser parse;
			string input = "today";
			vector<int> result;
			vector<int> expected = parse.currentTime();

			result = parse.extractYearMonthDay(input);
			Assert::AreEqual(result[0], expected[0]);
			Assert::AreEqual(result[1], expected[1]);
			Assert::AreEqual(result[2], expected[2]);
		}

		//test for case where year, month and day are all changed
		TEST_METHOD(solveDayOverFlowTest1) {
			Parser parse;
	
			int inputYear = 2015;
			int inputMonth = 12;
			int inputDay = 37;
			int expectedYear = 2016;
			int expectedMonth = 1;
			int exprctedDay = 6;

			parse.solveDayOverFlow(inputYear, inputMonth, inputDay);
			Assert::AreEqual(inputYear, expectedYear);
			Assert::AreEqual(inputMonth, expectedMonth);
			Assert::AreEqual(inputDay, exprctedDay);
		}

		//test for case of febuary in leap year
		TEST_METHOD(solveDayOverFlowTest2) {
			Parser parse;

			int inputYear = 2016;
			int inputMonth = 2;
			int inputDay = 32;
			int expectedYear = 2016;
			int expectedMonth = 3;
			int exprctedDay = 3;

			parse.solveDayOverFlow(inputYear, inputMonth, inputDay);
			Assert::AreEqual(inputYear, expectedYear);
			Assert::AreEqual(inputMonth, expectedMonth);
			Assert::AreEqual(inputDay, exprctedDay);
		}

		//test for case of febuary in non leap year
		TEST_METHOD(solveDayOverFlowTest3) {
			Parser parse;

			int inputYear = 2015;
			int inputMonth = 2;
			int inputDay = 32;
			int expectedYear = 2015;
			int expectedMonth = 3;
			int exprctedDay = 4;

			parse.solveDayOverFlow(inputYear, inputMonth, inputDay);
			Assert::AreEqual(inputYear, expectedYear);
			Assert::AreEqual(inputMonth, expectedMonth);
			Assert::AreEqual(inputDay, exprctedDay);
		}

		//non leap year
		TEST_METHOD(numberOfDaysInMonthTest1) {
			Parser parse;
			int inputMonth1 = 2;
			int inputYear1 = 2015;
			int expected1 = 28;

			Assert::AreEqual(parse.numberOfDaysInMonth(inputYear1, inputMonth1), expected1);
		}

		//leap year
		TEST_METHOD(numberOfDaysInMonthTest2) {
			Parser parse;
			int inputMonth2 = 2;
			int inputYear2 = 2016;
			int expected2 = 29;
	
			Assert::AreEqual(parse.numberOfDaysInMonth(inputYear2, inputMonth2), expected2);
		}

		//month with 31
		TEST_METHOD(numberOfDaysInMonthTest3) {
			Parser parse;
			int inputMonth3 = 12;
			int inputYear3 = 2015;
			int expected3 = 31;

			Assert::AreEqual(parse.numberOfDaysInMonth(inputYear3, inputMonth3), expected3);
		}

		//month with 30
		TEST_METHOD(numberOfDaysInMonthTest4) {
			Parser parse;
			int inputMonth4 = 4;
			int inputYear4 = 2015;
			int expected4 = 30;

			Assert::AreEqual(parse.numberOfDaysInMonth(inputYear4, inputMonth4), expected4);
		}

		//invalid input
		TEST_METHOD(numberOfDaysInMonthTest5) {
			Parser parse;
			int inputMonth5 = 13;
			int inputYear5 = 2015;
			int expected5 = -1;

			Assert::AreEqual(parse.numberOfDaysInMonth(inputYear5, inputMonth5), expected5);
		}

		//non leap year
		TEST_METHOD(isLeapYearTest1) {
			Parser parse;
			int input1 = 2015;

			Assert::IsFalse(parse.isLeapYear(input1));
		}

		//leap year
		TEST_METHOD(isLeapYearTest2) {
			Parser parse;
			int input2 = 2016;

			Assert::IsTrue(parse.isLeapYear(input2));
		}

		//short form input
		TEST_METHOD(convertStringWeekdayToIntTest1) {
			Parser parse;
			string input1 = "fri";
			int expected1 = 5;

			Assert::AreEqual(parse.convertStringWeekdayToInt(input1), expected1);
		}

		//invalid input
		TEST_METHOD(convertStringWeekdayToIntTest2) {
			Parser parse;
			string input2 = "frii";
			int expected2 = -1;

			Assert::AreEqual(parse.convertStringWeekdayToInt(input2), expected2);
		}

		//full input
		TEST_METHOD(convertStringWeekdayToIntTest3) {
			Parser parse;
			string input3 = "friday";
			int expected3 = 5;

			Assert::AreEqual(parse.convertStringWeekdayToInt(input3), expected3);
		}

		//short form input
		TEST_METHOD(convertStringMonthToIntTest1) {
			Parser parse;
			string input1 = "jan";
			int expected1 = 1;

			Assert::AreEqual(parse.convertStringMonthToInt(input1), expected1);
		}

		//invalid input
		TEST_METHOD(convertStringMonthToIntTest2) {
			Parser parse;
			string input2 = "jann";
			int expected2 = -1;

			Assert::AreEqual(parse.convertStringMonthToInt(input2), expected2);
		}

		//full input
		TEST_METHOD(convertStringMonthToIntTest3) {
			Parser parse;
			string input3 = "january";
			int expected3 = 1;

			Assert::AreEqual(parse.convertStringMonthToInt(input3), expected3);
		}

		TEST_METHOD(isDayValidTest1) {
			Parser parse;
			string inputDay1 = "31";
			int inputMonth1 = 2;
			int inputYear1 = 2015;
			int expected1 = -1;

			Assert::AreEqual(parse.isDayValid(inputYear1, inputMonth1, inputDay1), expected1);
		}

		//boundary value test case 1
		TEST_METHOD(isDayValidTest2) {
			Parser parse;
			string inputDay2 = "28";
			int inputMonth2 = 2;
			int inputYear2 = 2015;
			int expected2 = 28;

			Assert::AreEqual(parse.isDayValid(inputYear2, inputMonth2, inputDay2), expected2);
		}

		//boundary value test case 2
		TEST_METHOD(isDayValidTest3) {
			Parser parse;
			string inputDay3 = "31";
			int inputMonth3 = 12;
			int inputYear3 = 2015;
			int expected3 = 31;

			Assert::AreEqual(parse.isDayValid(inputYear3, inputMonth3, inputDay3), expected3);
		}

		//boundary value test case 3
		TEST_METHOD(isDayValidTest4) {
			Parser parse;
			string inputDay4 = "0";
			int inputMonth4 = 12;
			int inputYear4 = 2015;
			int expected4 = -1;

			Assert::AreEqual(parse.isDayValid(inputYear4, inputMonth4, inputDay4), expected4);
		}

		//boundary value test case 4
		TEST_METHOD(isDayValidTest5) {
			Parser parse;
			string inputDay5 = "1";
			int inputMonth5 = 1;
			int inputYear5 = 2015;
			int expected5 = 1;

			Assert::AreEqual(parse.isDayValid(inputYear5, inputMonth5, inputDay5), expected5);
		}

		//boundary value test case 1
		TEST_METHOD(isMonthValidTest1) {
			Parser parse;
			string input1 = "12";
			int expected1 = 12;

			Assert::AreEqual(parse.isMonthValid(input1), expected1);
		}

		//boundary value test case 2
		TEST_METHOD(isMonthValidTest2) {
			Parser parse;
			//boundary value
			string input2 = "1";
			int expected2 = 1;

			Assert::AreEqual(parse.isMonthValid(input2), expected2);
		}

		//boundary value test case 3
		TEST_METHOD(isMonthValidTest3) {
			Parser parse;
			string input3 = "0";
			int expected3 = -1;

			Assert::AreEqual(parse.isMonthValid(input3), expected3);
		}

		//boundary value test case 4
		TEST_METHOD(isMonthValidTest4) {
			Parser parse;
			string input4 = "13";
			int expected4 = -1;

			Assert::AreEqual(parse.isMonthValid(input4), expected4);
		}

		//boundary value test case 1
		TEST_METHOD(isYearValidTest1) {
			Parser parse;
			string input2 = "2000";
			int expected2 = 2000;

			Assert::AreEqual(parse.isYearValid(input2), expected2);
		}

		//boundary value test case 2
		TEST_METHOD(isYearValidTest2) {
			Parser parse;
			string input3 = "2999";
			int expected3 = 2999;

			Assert::AreEqual(parse.isYearValid(input3), expected3);
		}

		//boundary value test case 3
		TEST_METHOD(isYearValidTest3) {
			Parser parse;
			string input4 = "3000";
			int expected4 = -1;

			Assert::AreEqual(parse.isYearValid(input4), expected4);
		}

		//boundary value test case 4
		TEST_METHOD(isYearValidTest4) {
			Parser parse;
			string input5 = "1999";
			int expected5 = -1;

			Assert::AreEqual(parse.isYearValid(input5), expected5);
		}

		//boundary value test case 1
		TEST_METHOD(extractTimeTest1) {
			Parser parse;
			string input = "2359";
			int expected = 2359;

			Assert::AreEqual(parse.extractTime(input), expected);
		}

		//boundary value test case 2
		TEST_METHOD(extractTimeTest2) {
			Parser parse;
			string input = "0000";
			int expected = 0;

			Assert::AreEqual(parse.extractTime(input), expected);
		}

		//boundary value test case 1
		TEST_METHOD(isTimeValidTest1) {
			Parser parse;
			int inputHour = 0;
			int inputMinute = 0;

			Assert::IsTrue(parse.isTimeValid(inputHour, inputMinute));
		}

		//boundary value test case 2
		TEST_METHOD(isTimeValidTest2) {
			Parser parse;
			int inputHour = 23;
			int inputMinute = 59;

			Assert::IsTrue(parse.isTimeValid(inputHour, inputMinute));
		}

		//boundary value test case 3
		TEST_METHOD(isTimeValidTest3) {
			Parser parse;
			int inputHour = 24;
			int inputMinute = 0;

			Assert::IsFalse(parse.isTimeValid(inputHour, inputMinute));
		}

		//boundary value test case 4
		TEST_METHOD(isTimeValidTest4) {
			Parser parse;
			int inputHour = 23;
			int inputMinute = 60;

			Assert::IsFalse(parse.isTimeValid(inputHour, inputMinute));
		}

		TEST_METHOD(fragmentizeStringTest1) {
			Parser parse;
			string input = "watch spy    bridge   tmr";
			vector<string> output;
			string expectedFirstWord = "watch";
			string expectedSecondtWord = "spy";
			string expectedThirdWord = "bridge";
			string expectedFourthWord = "tmr";

			output = parse.fragmentizeString(input);
			
			Assert::AreEqual(output[0], expectedFirstWord);
			Assert::AreEqual(output[1], expectedSecondtWord);
			Assert::AreEqual(output[2], expectedThirdWord);
			Assert::AreEqual(output[3], expectedFourthWord);
		}

		//with valid delimiter
		TEST_METHOD(findDateDelimiterPosTest1) {
			Parser parse;
			string input = "watch movie on mon";
			size_t expected = 12;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with invalid delimiter
		TEST_METHOD(findDateDelimiterPosTest2) {
			Parser parse;
			string input = "watch movie oon mon";
			size_t expected = string::npos;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//without a delimiter
		TEST_METHOD(findDateDelimiterPosTest3) {
			Parser parse;
			string input = "watch movie";
			size_t expected = string::npos;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with 2 delimitors occurrence
		TEST_METHOD(findDateDelimiterPosTest4) {
			Parser parse;
			string input = "watch the man on tuesday on mon 12";
			size_t expected = 25;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with quotation only
		TEST_METHOD(findDateDelimiterPosTest5) {
			Parser parse;
			string input = "\"watch the man on tue\"";
			size_t expected = string::npos;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with quotation followed by date & time keywords
		TEST_METHOD(findDateDelimiterPosTest6) {
			Parser parse;
			string input = "\"watch the man on tue\" fri 12";
			size_t expected = 21;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with quotation followed by delimiter and date & time keywords
		TEST_METHOD(findDateDelimiterPosTest7) {
			Parser parse;
			string input = "\"watch the man on tue\" on fri 12";
			size_t expected = 23;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with quotation followed by delimiter without space and date & time keywords
		TEST_METHOD(findDateDelimiterPosTest8) {
			Parser parse;
			string input = "\"watch the man on tue\"on fri 12";
			size_t expected = 21;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with quotation followed by invalid delimiter with space and date & time keywords
		TEST_METHOD(findDateDelimiterPosTest9) {
			Parser parse;
			string input = "\"watch the man on tue\" yo fri 12";
			size_t expected = string::npos;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		//with quotation followed by invalid delimiter without space and date & time keywords
		TEST_METHOD(findDateDelimiterPosTest10) {
			Parser parse;
			string input = "\"watch the man on tue\"yo fri 12";
			size_t expected = 21;

			Assert::AreEqual(parse.findDateDelimiterPos(input), expected);
		}

		TEST_METHOD(convertStringToIntTest1) {
			Parser parse;
			string input = "123";
			int expected = 123;

			Assert::AreEqual(parse.convertStringToInt(input), expected);
		}

	};
}
```
###### ParserTest\stdafx.h
``` h
#include "Parser.h"
```
