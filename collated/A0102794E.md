# A0102794E
###### Doowado - Task Manager\CommandTest\DisplayStub.cpp
``` cpp

DisplayStub::DisplayStub()
{
}


DisplayStub::~DisplayStub()
{
}

vector<Entry*> DisplayStub::getEventsList()
{
	return _eventList;
}

Entry * DisplayStub::retrieveEntry(EntryType entryType, int taskID) {
	
	return _eventList[0];
}
```
###### Doowado - Task Manager\CommandTest\DisplayStub.h
``` h

class DisplayStub: public Display
{
public:
	DisplayStub();
	~DisplayStub();

	vector<Entry*> getEventsList();
	Entry* retrieveEntry(EntryType, int);
};


```
###### Doowado - Task Manager\CommandTest\LogicShowTest.cpp
``` cpp
namespace LogicShowTest
{
	//Tests the overall function of logic with storage, starting with a show command
	// and validating display
	TEST_CLASS(LogicShowTest)
	{
		
	//create hard-coded entries on various dates
		date date1 = date(2015, Nov, 1);
		date date2 = date(2015, Nov, 2);
		date date3 = date(2015, Nov, 3);
		date date4 = date(2015, Nov, 4);

		ptime time1OnDate1 = ptime(date1, hours(1));
		ptime time2OnDate1 = ptime(date1, hours(2));
		ptime time3OnDate1 = ptime(date1, hours(3));

		ptime time1OnDate2 = ptime(date2, hours(1));
		ptime time2OnDate2 = ptime(date2, hours(2));
		
		ptime time1OnDate3 = ptime(date3, hours(1));
		ptime time2OnDate3 = ptime(date3, hours(2));
		
		ptime time1OnDate4 = ptime(date4, hours(1));
		ptime time2OnDate4 = ptime(date4, hours(2));

		Entry* earlierEntryOnDate1 = new Entry("earlierEntryOnDate1", time1OnDate1, time2OnDate1);
		Entry* laterEntryOnDate1 = new Entry("laterEntryOnDate1", time2OnDate1, time3OnDate1);
		Entry* entryOnDate2 = new Entry("entryOnDate2", time1OnDate2, time2OnDate2);
		Entry* entryOnDate3 = new Entry("entryOnDate3", time1OnDate3, time2OnDate3);
		Entry* entryOnDate4 = new Entry("entryOnDate4", time1OnDate4, time2OnDate4);

		Entry* earlierTimedTaskOnDate1 = new Entry("earlierTimedTaskOnDate1", time1OnDate1);
		Entry* laterTimedTaskOnDate1 = new Entry("laterTimedTaskOnDate1", time2OnDate1);
		Entry* timedTaskOnDate2 = new Entry("timedTaskOnDate2", time1OnDate2);
		Entry* timedTaskOnDate3 = new Entry("timedTaskOnDate3", time1OnDate3);
		Entry* timedTaskOnDate4 = new Entry("timedTaskOnDate4", time1OnDate4);
		Entry* floatingTask1 = new Entry("floatingTask1");
		Entry* floatingTask2 = new Entry("floatingTask2");


		//ShowByDate tests show for date1
			//all values trated the same way by this function
		//ShowByRangeOfDate tests show for date1 to date 3
			//two test events & tasks on date1 (start of range)
			//one test event & task on date 2 (within range)
			//one test event & task on date 3 (end of range)
			//one test event & task on date 4 (out of range)
			//two floating tasks (always shown in display by dates)
		//ShowCompleted tests display of completed tasks
			// two timed tasks on diff days and one floating task are marked done during initialization
			// checks that the display task list comprises of these three 
		//ShowOverdue tests display of overdue tasks
			// three timed tasks on diff days are marked overdue during initialization
			// one of these is also completed
			// checks that the display task list comprises of two tasks (completed task should not be shown)
	public:

		TEST_METHOD(ShowByDate)
		{
			Storage storage;
			Display idealDisplay;
			Display actualDisplay;

			initializeHardcodedStorage(&storage);
			generateIdealDisplayByDate(&idealDisplay);

			ShowCommand showCmd(date1);
			showCmd.execute(&storage, &actualDisplay);

			validateDisplay(actualDisplay, idealDisplay);
		}

		TEST_METHOD(ShowByRangeOfDate)
		{
			Storage storage;
			Display idealDisplay;
			Display actualDisplay;
			initializeHardcodedStorage(&storage);

			generateIdealDisplayByRangeOfDate(&idealDisplay);

			ShowCommand showCmd(date1, date3);
			showCmd.execute(&storage, &actualDisplay);

			validateDisplay(actualDisplay, idealDisplay);
		}

		TEST_METHOD(ShowCompleted)
		{
			Storage storage;
			Display idealDisplay;
			Display actualDisplay;
			initializeHardcodedStorage(&storage);

			generateIdealDisplayByCompleted(&idealDisplay);

			ShowCommand showCmd(completed);
			showCmd.execute(&storage, &actualDisplay);

			validateDisplay(actualDisplay, idealDisplay);
		}

		TEST_METHOD(ShowOverdue)
		{
			Storage storage;
			Display idealDisplay;
			Display actualDisplay;
			initializeHardcodedStorage(&storage);

			generateIdealDisplayByOverdue(&idealDisplay);

			ShowCommand showCmd(overdue);
			showCmd.execute(&storage, &actualDisplay);

			validateDisplay(actualDisplay, idealDisplay);
		}

		void initializeHardcodedStorage(Storage* storage) {
			vector<Entry*> hardcodedEventList;
			vector<Entry*> hardcodedTaskList;

			earlierTimedTaskOnDate1->setDone(true);
			timedTaskOnDate3->setDone(true);
			floatingTask1->setDone(true);

			earlierTimedTaskOnDate1->setOverdue(true);
			laterTimedTaskOnDate1->setOverdue(true);
			timedTaskOnDate4->setOverdue(true);

			hardcodedEventList.push_back(earlierEntryOnDate1);
			hardcodedEventList.push_back(laterEntryOnDate1);
			hardcodedEventList.push_back(entryOnDate2);
			hardcodedEventList.push_back(entryOnDate3);
			hardcodedEventList.push_back(entryOnDate4);

			hardcodedTaskList.push_back(earlierTimedTaskOnDate1);
			hardcodedTaskList.push_back(laterTimedTaskOnDate1);
			hardcodedTaskList.push_back(timedTaskOnDate2);
			hardcodedTaskList.push_back(timedTaskOnDate3);
			hardcodedTaskList.push_back(timedTaskOnDate4);
			hardcodedTaskList.push_back(floatingTask1);
			hardcodedTaskList.push_back(floatingTask2);

			storage->setEventList(hardcodedEventList);
			storage->setTaskList(hardcodedTaskList);
		}

		void generateIdealDisplayByDate(Display* idealDisplay) {
			vector<string> idealCmdFeedback;
			vector<Entry*> idealDisplayEventList;
			vector<Entry*> idealDisplayTaskList;

			idealCmdFeedback.push_back("Showing: ");
			idealCmdFeedback.push_back(to_simple_string(date1));

			idealDisplayEventList.push_back(earlierEntryOnDate1);
			idealDisplayEventList.push_back(laterEntryOnDate1);

			idealDisplayTaskList.push_back(earlierTimedTaskOnDate1);
			idealDisplayTaskList.push_back(laterTimedTaskOnDate1);
			idealDisplayTaskList.push_back(floatingTask1);
			idealDisplayTaskList.push_back(floatingTask2);


			idealDisplay->updateCommandFeedback(idealCmdFeedback);
			idealDisplay->updateDisplayEventList(idealDisplayEventList);
			idealDisplay->updateDisplayTaskList(idealDisplayTaskList);
		}

		void generateIdealDisplayByRangeOfDate(Display* idealDisplay) {
			vector<string> idealCmdFeedback;
			vector<Entry*> idealDisplayEventList;
			vector<Entry*> idealDisplayTaskList;

			idealCmdFeedback.push_back("Showing: ");
			idealCmdFeedback.push_back(to_simple_string(date1));
			idealCmdFeedback.push_back(to_simple_string(date3));

			idealDisplayEventList.push_back(earlierEntryOnDate1);
			idealDisplayEventList.push_back(laterEntryOnDate1);
			idealDisplayEventList.push_back(entryOnDate2);
			idealDisplayEventList.push_back(entryOnDate3);

			idealDisplayTaskList.push_back(earlierTimedTaskOnDate1);
			idealDisplayTaskList.push_back(laterTimedTaskOnDate1);
			idealDisplayTaskList.push_back(timedTaskOnDate2);
			idealDisplayTaskList.push_back(timedTaskOnDate3);
			idealDisplayTaskList.push_back(floatingTask1);
			idealDisplayTaskList.push_back(floatingTask2);

			idealDisplay->updateCommandFeedback(idealCmdFeedback);
			idealDisplay->updateDisplayEventList(idealDisplayEventList);
			idealDisplay->updateDisplayTaskList(idealDisplayTaskList);
		}

		void generateIdealDisplayByCompleted(Display* idealDisplay) {
			vector<string> idealCmdFeedback;
			vector<Entry*> idealDisplayEventList;
			vector<Entry*> idealDisplayTaskList;

			idealCmdFeedback.push_back("Showing: ");
			idealCmdFeedback.push_back("completed");

			//event list should not be updated

			idealDisplayTaskList.push_back(earlierTimedTaskOnDate1);
			idealDisplayTaskList.push_back(timedTaskOnDate3);
			idealDisplayTaskList.push_back(floatingTask1);

			idealDisplay->updateCommandFeedback(idealCmdFeedback);
			idealDisplay->updateDisplayEventList(idealDisplayEventList);
			idealDisplay->updateDisplayTaskList(idealDisplayTaskList);
		}

		void generateIdealDisplayByOverdue(Display* idealDisplay) {
			vector<string> idealCmdFeedback;
			vector<Entry*> idealDisplayEventList;
			vector<Entry*> idealDisplayTaskList;
			
			idealCmdFeedback.push_back("Showing: ");
			idealCmdFeedback.push_back("overdue");

			//event list should not be updated

			idealDisplayTaskList.push_back(laterTimedTaskOnDate1);
			idealDisplayTaskList.push_back(timedTaskOnDate4);

			idealDisplay->updateCommandFeedback(idealCmdFeedback);
			idealDisplay->updateDisplayEventList(idealDisplayEventList);
			idealDisplay->updateDisplayTaskList(idealDisplayTaskList);
		}
		//methods below are exactly the same as Display validation in SystemTest
		void validateDisplay(Display actualDisplay, Display idealDisplay) {
			validateCmdFeedback(actualDisplay, idealDisplay);
			validateEventList(actualDisplay, idealDisplay);
			validateTaskList(actualDisplay, idealDisplay);
		}

		void validateCmdFeedback(Display actualDisplay, Display idealDisplay) {

			vector<string> actualFeedback = actualDisplay.getCommandFeedback();
			vector<string> idealFeedback = idealDisplay.getCommandFeedback();

			Assert::IsTrue(areSameFeedback(actualFeedback, idealFeedback));

		}

		void validateEventList(Display actualDisplay, Display idealDisplay) {
			vector<Entry*> actualEventList = actualDisplay.getEventList();
			vector<Entry*> idealEventList = idealDisplay.getEventList();

			Assert::AreEqual(actualEventList.size(), idealEventList.size());
			Assert::IsTrue(areSameEntryList(actualEventList, idealEventList, event));
		}

		void validateTaskList(Display actualDisplay, Display idealDisplay) {
			vector<Entry*> actualTaskList = actualDisplay.getTaskList();
			vector<Entry*> idealTaskList = idealDisplay.getTaskList();

			Assert::AreEqual(actualTaskList.size(), idealTaskList.size());
			Assert::IsTrue(areSameEntryList(actualTaskList, idealTaskList, task));
		}

		bool areSameFeedback(vector<string> feedback1, vector<string> feedback2) {
			Assert::AreEqual(feedback1.size(), feedback2.size());

			for (int i = 0; i < feedback2.size(); i++) {
				if (feedback1[i] != feedback2[i]) {
					return false;
				}
			}
			return true;
		}

		bool areSameEntry(Entry* entry1, Entry* entry2, EntryType entryType) {
			if (entryType == event) {
				return(entry1->getTitle() == entry2->getTitle()
					&& entry1->getStartTime() == entry2->getStartTime()
					&& entry1->getEndTime() == entry2->getEndTime());
			}
			if (entryType == task) {
				return(entry1->getTitle() == entry2->getTitle()
					&& entry1->getEndTime() == entry2->getEndTime()
					);
			}
		}

		bool areSameEntryList(vector<Entry*> list1, vector<Entry*> list2, EntryType entryType) {
			for (int i = 0; i < list2.size(); i++) {
				if (!areSameEntry(list1[i], list2[i], entryType)) {
					return false;
				}
			}
			return true;
		}

	};
}
```
###### Doowado - Task Manager\CommandTest\LogicTest.cpp
``` cpp

namespace LogicTest
{
	//Tests the overall function of logic with storage, starting with an add command
	// and validating history, storage and display
	TEST_CLASS(LogicTest)
	{
	public:

		TEST_METHOD(AddEventToEmptyStorage)
		{
			//hard-coded event on 29 Oct 2015 from 5 to 7
			string testName = "Timed event";

			date testDate = date(2015, Oct, 29);
			ptime time1 = ptime(testDate, hours(5));
			ptime time2 = ptime(testDate, hours(7));

			Entry newEntry = Entry(testName, time1, time2);

			Display displayList;
			Storage testStorage;
			History history;

			vector<Entry*> actualStorageEventList;
			vector<Entry*> actualStorageTaskList;

			vector<Entry*> IdealStorageEventList;
			vector<Entry*> IdealStorageTaskList;
			IdealStorageEventList.push_back(&newEntry);

			vector<string> actualFeedback;
			vector<string> idealFeedback;
			idealFeedback.push_back("Added");
			idealFeedback.push_back(testName);
			idealFeedback.push_back(to_simple_string(time1));
			idealFeedback.push_back(to_simple_string(time2));

			vector<Entry*> actualDisplayEventList;
			vector<Entry*> idealDisplayEventList;
			idealDisplayEventList.push_back(&newEntry);

			vector<Entry*> actualDisplayTaskList;
			vector<Entry*> idealDisplayTaskList;

			AddCommand addCmd(testName, time1, time2);

			addCmd.execute(&testStorage, &displayList);

			// Check storage
			actualStorageEventList = testStorage.getEventList();
			actualStorageTaskList = testStorage.getTaskList();

			Assert::AreEqual(actualStorageEventList.size(), IdealStorageEventList.size());
			Assert::AreEqual(actualStorageTaskList.size(), IdealStorageTaskList.size());


			Assert::IsTrue(areSameList(actualStorageEventList, IdealStorageEventList));
			Assert::IsTrue(areSameList(actualStorageTaskList, IdealStorageTaskList));

			for (int i = 0; i < IdealStorageTaskList.size(); i++) {
				Assert::IsTrue(areEqual(actualStorageTaskList[i], IdealStorageTaskList[i]));
			}

			//Check history
			Assert::AreEqual(History::getSize(), size_t(1));

			//Check display
			actualFeedback = displayList.getCommandFeedback();
			Assert::IsTrue(areSameFeedback(actualFeedback, idealFeedback));

			actualDisplayEventList = displayList.getEventList();
			actualDisplayTaskList = displayList.getTaskList();

			Assert::AreEqual(actualDisplayEventList.size(), idealDisplayEventList.size());
			Assert::AreEqual(actualDisplayTaskList.size(), idealDisplayTaskList.size());

			Assert::IsTrue(areSameList(actualDisplayEventList, idealDisplayEventList));
			Assert::IsTrue(areSameList(actualDisplayTaskList, idealDisplayTaskList));
		}

		/*TEST_METHOD(AddTaskToEmptyStorage)
		{
			//hard-coded task on 29 Oct 2015 due 5
			string testName = "Timed task";

			date testDate = date(2015, Oct, 29);
			ptime time1 = ptime(testDate, hours(5));
			ptime time2;

			Entry newEntry = Entry(testName, time1, time2);

			Display displayList;
			Storage testStorage;
			History history;

			vector<Entry*> actualStorageEventList;
			vector<Entry*> actualStorageTaskList;

			vector<Entry*> IdealStorageEventList;
			vector<Entry*> IdealStorageTaskList;
			IdealStorageTaskList.push_back(&newEntry);

			vector<string> actualFeedback;
			vector<string> idealFeedback;
			idealFeedback.push_back("Added");
			idealFeedback.push_back(testName);
			idealFeedback.push_back(to_simple_string(time1));

			vector<Entry*> actualDisplayEventList;
			vector<Entry*> idealDisplayEventList;

			vector<Entry*> actualDisplayTaskList;
			vector<Entry*> idealDisplayTaskList;
			idealDisplayTaskList.push_back(&newEntry);

			AddCommand addCmd(testName, time1, time2);

			addCmd.execute(&testStorage, &displayList);

			// Check storage
			actualStorageEventList = testStorage.getEventList();
			actualStorageTaskList = testStorage.getTaskList();

			//Assert::AreEqual(actualStorageEventList.size(), IdealStorageEventList.size());
			Assert::AreEqual(actualStorageTaskList.size(), size_t(1));


			Assert::IsTrue(areSameList(actualStorageEventList, IdealStorageEventList));
			Assert::IsTrue(areSameList(actualStorageTaskList, IdealStorageTaskList));

			//Check history
			Assert::AreEqual(History::getSize(), size_t(1));

			//Check display
			actualFeedback = displayList.getCommandFeedback();
			Assert::IsTrue(areSameFeedback(actualFeedback, idealFeedback));

			actualDisplayEventList = displayList.getEventList();
			actualDisplayTaskList = displayList.getTaskList();

			Assert::AreEqual(actualDisplayEventList.size(), idealDisplayEventList.size());
			Assert::AreEqual(actualDisplayTaskList.size(), idealDisplayTaskList.size());

			Assert::IsTrue(areSameList(actualDisplayEventList, idealDisplayEventList));
			Assert::IsTrue(areSameList(actualDisplayTaskList, idealDisplayTaskList));
		}
		*/

		bool areEqual(Entry* entry1, Entry* entry2) {
			return(entry1->getTitle() == entry2->getTitle() 
				&&	entry1->getStartTime() == entry2->getStartTime() 
				&&  entry1->getEndTime() == entry2->getEndTime()
				);
		}

		bool areSameFeedback(vector<string> feedback1, vector<string> feedback2) {
			for (int i = 0; i < feedback2.size(); i++) {
				if (feedback1[i] != feedback2[i]) {
					return false;
				}
			}
			return true;
		}

		bool areSameList(vector<Entry*> list1, vector<Entry*> list2) {
			for (int i = 0; i < list2.size(); i++) {
				if (!areEqual(list1[i], list2[i])) {
					return false;
				}
			}
			return true;
		}
	};
}
```
###### Doowado - Task Manager\CommandTest\ReversibleCommandStub.cpp
``` cpp

ReversibleCommandStub::ReversibleCommandStub()
{
}


ReversibleCommandStub::~ReversibleCommandStub()
{
}

void ReversibleCommandStub::undo(Storage *storage, Display *display)
{
	vector<string> hardCodedFeedback;
	hardCodedFeedback.push_back("Undo Complete");
	display->updateCommandFeedback(hardCodedFeedback);
}
```
###### Doowado - Task Manager\CommandTest\ReversibleCommandStub.h
``` h

class ReversibleCommandStub: public Command
{
public:
	ReversibleCommandStub();
	~ReversibleCommandStub();

	void undo(Storage*, Display*);
};

```
###### Doowado - Task Manager\CommandTest\ShowCommandTest.cpp
``` cpp

namespace CommandTest
{		
	TEST_CLASS(ShowCommandTest)
	{
	public:
		
		TEST_METHOD(ConstructorTest)
		{
			date testDate(2015,Oct,17);
			
			ShowCommand* cmd;
			cmd = new ShowCommand(testDate);

			Assert::AreEqual(to_simple_string(cmd->_requestedEndDate),to_simple_string(testDate));
		}

		TEST_METHOD(ShowEventByDateTest)
		{
			date testDate(2015, Oct, 18);
			ptime t1(testDate, hours(5) + minutes(30));
			ptime t2(testDate, hours(6) + minutes(30));

			ShowCommand* cmd;
			cmd = new ShowCommand(testDate);

			DisplayStub displayList;
			StorageStub testStorage;

			Entry event1("Sample event", t1, t2);
			testStorage.addEvent(&event1);

			vector<Entry*> idealEventsList;
			idealEventsList.push_back(&event1);

			vector<Entry*> actualEventsList;

			cmd->execute(&testStorage, &displayList);
			Assert::AreEqual((cmd->_requestedEventList).size(),size_t(1));
			
		}

	};
} 
```
###### Doowado - Task Manager\CommandTest\StorageStub.cpp
``` cpp

StorageStub::StorageStub()
{
}

StorageStub::~StorageStub()
{
}

void StorageStub::displayByDate(vector<Entry*>* eventList, vector<Entry*>* taskList, date)
{
	*eventList = _eventList;
	*taskList = _taskList;
}

vector<Entry*> StorageStub::getEventsList()
{
	return _eventList;
}

vector<Entry*> StorageStub::getTasksList()
{
	return _taskList;
}
```
###### Doowado - Task Manager\CommandTest\StorageStub.h
``` h

class StorageStub: public Storage
{
public:
	StorageStub();
	~StorageStub();

	void displayByDate(vector<Entry*>*, vector<Entry*>*, date);
	vector<Entry*> getEventsList();
	vector<Entry*> getTasksList();
};

```
###### Doowado - Task Manager\CommandTest\StubTests.cpp
``` cpp

namespace CommandTest
{
	TEST_CLASS(StubTests)
	{
	public:

		TEST_METHOD(StorageStubAddEventTest)
		{
			date testDate(2015, Oct, 18);
			ptime t1(testDate, hours(5) + minutes(30));
			ptime t2(testDate, hours(6) + minutes(30));

			StorageStub testStorage;

			Entry event1("Sample event", t1, t2);
			testStorage.addEvent(&event1);

			vector<Entry*> actualEventsList;

			actualEventsList = testStorage.getEventsList();

			Assert::AreEqual(actualEventsList.size(), size_t(1));

		}

		TEST_METHOD(StorageStubDisplayByDateTest)
		{
			date testDate(2015, Oct, 18);
			ptime t1(testDate, hours(5) + minutes(30));
			ptime t2(testDate, hours(6) + minutes(30));

			StorageStub testStorage;

			Entry event1("Sample event", t1, t2);
			testStorage.addEvent(&event1);

			vector<Entry*> actualEventsList;
			vector<Entry*> actualTaskList;

			testStorage.displayByDate(&actualEventsList, &actualTaskList, testDate);

			Assert::AreEqual(actualEventsList.size(), size_t(1));

		}


		TEST_METHOD(DisplayStubTest)
		{
			date testDate(2015, Oct, 18);
			ptime t1(testDate, hours(5) + minutes(30));
			ptime t2(testDate, hours(6) + minutes(30));
			Entry event1("Sample event", t1, t2);
			vector<Entry*> testEventsList;
			testEventsList.push_back(&event1);

			DisplayStub displayList;

			displayList.updateDisplayEventList(testEventsList);

			vector<Entry*> actualEventsList;
			actualEventsList = displayList.getEventsList();

			Assert::AreEqual(actualEventsList.size(), size_t(1));
		}
	};
}
```
###### Doowado - Task Manager\CommandTest\UndoCommandTest.cpp
``` cpp

namespace CommandTest
{
	TEST_CLASS(UndoCommandTest)
	{
	public:

		TEST_METHOD(ConstructorTest)
		{
			UndoCommand* cmd;
			cmd = new UndoCommand();

		}

		/*TEST_METHOD(NoReversibleCommandTest)
		{
			const string MSG_NOTHING_TO_UNDO = "Nothing to undo";

			UndoCommand* cmd;
			cmd = new UndoCommand();

			DisplayStub displayList;
			StorageStub testStorage;
			HistoryStub history;

			vector<string> idealFeedback;
			vector<string> actualFeedback;

			cmd->execute(&testStorage, &displayList);

			actualFeedback = displayList.getCommandFeedback();
			idealFeedback.push_back(MSG_NOTHING_TO_UNDO);

			Assert::AreEqual(actualFeedback.size(), size_t(1));
			Assert::AreEqual(actualFeedback[0], idealFeedback[0]);
			
		}*/

		TEST_METHOD(OneReversibleCommandTest)
		{
			UndoCommand* cmd;
			cmd = new UndoCommand();

			DisplayStub displayList;
			StorageStub testStorage;
			HistoryStub history;
			ReversibleCommandStub reversibleCmd;

			vector<string> idealFeedback;
			vector<string> actualFeedback;

			history.pushCommand(&reversibleCmd);

			cmd->execute(&testStorage, &displayList);

			actualFeedback = displayList.getCommandFeedback();
			idealFeedback.push_back("Undo Complete");

			Assert::AreEqual(actualFeedback.size(), size_t(1));
			Assert::AreEqual(actualFeedback[0], idealFeedback[0]);
		}

		TEST_METHOD(TwoReversibleCommandsTest)
		{
			UndoCommand* cmd;
			cmd = new UndoCommand();

			DisplayStub displayList;
			StorageStub testStorage;
			HistoryStub history;
			ReversibleCommandStub reversibleCmd1;
			ReversibleCommandStub reversibleCmd2;

			vector<string> idealFeedback;
			vector<string> actualFeedback;
		
			history.pushCommand(&reversibleCmd1);
			history.pushCommand(&reversibleCmd2);
			idealFeedback.push_back("Undo Complete");

			for (int i = 0; i < 2; i++) {
				cmd->execute(&testStorage, &displayList);
				actualFeedback = displayList.getCommandFeedback();

				Assert::AreEqual(actualFeedback.size(), size_t(1));
				Assert::AreEqual(actualFeedback[0], idealFeedback[0]);
			}

		}

		TEST_METHOD(UndoAddCommandTest_DeleteEntry)
		{
			string testName = "Untimed task"; 

			ptime time1;
			ptime time2;


			DisplayStub displayList;
			StorageStub testStorage;
			//HistoryStub history;

			vector<Entry*> actualEventsList;
			vector<Entry*> actualTasksList;

			AddCommand addCmd(testName, time1, time2);
			addCmd.execute(&testStorage, &displayList);
			
			actualEventsList = testStorage.getEventsList();
			actualTasksList = testStorage.getTasksList();

			Assert::AreEqual(actualEventsList.size(), size_t(0));
			Assert::AreEqual(actualTasksList.size(), size_t(1));

			UndoCommand undoCmd;
			undoCmd.execute(&testStorage, &displayList);

			actualEventsList = testStorage.getEventsList();
			actualTasksList = testStorage.getTasksList();

			Assert::AreEqual(actualEventsList.size(), size_t(0));
			Assert::AreEqual(actualTasksList.size(), size_t(0));

		}

		TEST_METHOD(UndoAddCommandTest_SendFeedback)
		{
			string testName = "Untimed task";

			ptime time1;
			ptime time2;

			DisplayStub displayList;
			StorageStub testStorage;
			//HistoryStub history;

			vector<Entry*> actualEventsList;
			vector<Entry*> actualTasksList;

			vector<string> actualFeedback;
			vector<string> idealFeedback;

			idealFeedback.push_back("Undone");
			idealFeedback.push_back("Added");
			idealFeedback.push_back(testName);

			AddCommand addCmd(testName, time1, time2);
			addCmd.execute(&testStorage, &displayList);

			UndoCommand undoCmd;
			undoCmd.execute(&testStorage, &displayList);

			actualFeedback = displayList.getCommandFeedback();

			Assert::AreEqual(actualFeedback.size(), idealFeedback.size());
			
			for (int i = 0; i < idealFeedback.size(); i++) {
				Assert::AreEqual(actualFeedback[i], idealFeedback[i]);
			}
		}

		/*TEST_METHOD(UndoEditCommandTest_SendFeedback)
		{
			
			EntryType entryType = event;
			int taskID = 1;
			string newTitle = "New Name";
			ptime newStartDate;
			ptime newStartTime;
			ptime newEndDate;
			ptime newEndTime;
			EditCommand* editCmd = new EditCommand(entryType, taskID, newTitle, newStartDate, newStartTime, newEndDate, newEndTime);
			
			DisplayStub display;
			Entry* testOldEntry;
			string oldName = "Old Name";
			ptime t1;
			ptime t2;
			vector<Entry*> testEventList;

			testOldEntry = new Entry(oldName, t1, t2);
			testEventList.push_back(testOldEntry);
			display.updateDisplayEventList(testEventList);
			
			Storage testStorage;

			
			editCmd->execute(&testStorage, &display);
			//Assert::AreEqual(History::getSize(), size_t(1));
			
		}*/
		
		//test undo of deletion on an event
		TEST_METHOD(UndoDeleteCommandTestEvent) {
			
			//create event and single-event event list
			EntryType entryType = event;
			int taskID = 0;
			DeleteCommand delCmd(entryType, taskID);
			Display display;
			Entry* testDeleteEntry;
			string name = "Old Name";
			ptime t1;
			ptime t2;
			vector<Entry*> testEventList;

			size_t historySize;
			Entry* actualStorageEntryAfterUndo;

			testDeleteEntry = new Entry(name, t1, t2);
			testEventList.push_back(testDeleteEntry);
			display.updateDisplayEventList(testEventList);

			// check that display has and returns the correct entry
			Assert::AreEqual(display.getEventList().size(), size_t(1));
			Entry* actualDisplayEntry = (display.getEventList())[0];
			Assert::AreEqual(actualDisplayEntry->getTitle(), name);
			Entry* actualRetrievedEntry = display.retrieveEntry(entryType, taskID);
			Assert::AreEqual(actualRetrievedEntry->getTitle(), name);

			Storage testStorage;
			testStorage.addEvent(testDeleteEntry);

			History::empty();

			vector<string> actualFeedbackAfterUndo;
			vector<string> idealFeedbackAfterUndo;


			//check storage size is 1, history size is 0
			size_t storageSize = (testStorage.getEventList()).size();
			Assert::AreEqual(storageSize, size_t(1));

			delCmd.execute(&testStorage, &display);

			//check storage size is 0
			storageSize = (testStorage.getEventList()).size();
			Assert::AreEqual(storageSize, size_t(0));

			historySize = History::getSize();
			Assert::AreEqual(historySize, size_t(1));

			idealFeedbackAfterUndo = display.getCommandFeedback();
			vector<string>::iterator front = idealFeedbackAfterUndo.begin();
			idealFeedbackAfterUndo.insert(front, "Undone");

			UndoCommand undoCmd;
			undoCmd.execute(&testStorage, &display);
			Assert::AreEqual(historySize, size_t(1));

			storageSize = (testStorage.getEventList()).size();
			Assert::AreEqual(storageSize, size_t(1));

			actualStorageEntryAfterUndo = (testStorage.getEventList())[0];
			Assert::AreEqual(actualStorageEntryAfterUndo->getTitle(), name);

			actualFeedbackAfterUndo = display.getCommandFeedback();

			Assert::AreEqual(actualFeedbackAfterUndo.size(), idealFeedbackAfterUndo.size());

			for (int i = 0; i < idealFeedbackAfterUndo.size(); i++) {
				Assert::AreEqual(actualFeedbackAfterUndo[i], idealFeedbackAfterUndo[i]);
			}
			
		}

		
		//test undo on deletion of task
		TEST_METHOD(UndoDeleteCommandTestTask) {

			//create test task and single-task task list
			Entry* testTask;
			string name = "Name";
			ptime t1;
			vector<Entry*> testTaskList;
			testTask = new Entry(name, t1);
			testTaskList.push_back(testTask);
			
			//create command to delete test task at [0]
			EntryType entryType = task;
			int taskID = 0;
			DeleteCommand delCmd(entryType, taskID);
			
			//create neceessary objects and parameters
			Display display;
			Storage testStorage;
			size_t historySize;
			vector<string> feedbackAfterExecute;
			vector<string> feedbackAfterUndo;
			vector<Entry*> taskListAfterUndo;
			vector<Entry*> expectedDisplayTaskListAfterUndo;
			vector<Entry*> expectedDisplayEventListAfterUndo;

			//set up display, storage and history for deletion of test task
			display.updateDisplayTaskList(testTaskList);
			testStorage.addTask(testTask);
			History::empty();
			
			delCmd.execute(&testStorage, &display);

			assertStorageListSize(&testStorage, task, 0);
			assertHistorySize(1);
			getFeedback(&feedbackAfterExecute, &display);

			UndoCommand undoCmd;
			undoCmd.execute(&testStorage, &display);

			assertHistorySize(0);
			assertStorageListSize(&testStorage, task, 1);
			getFeedback(&feedbackAfterUndo, &display);
			getDisplayTaskList(&taskListAfterUndo, &display);

			checkTaskRestored(&testStorage, testTask);
			validateUndoFeedback(feedbackAfterExecute, feedbackAfterUndo);
			validateDisplayLists(&display, expectedDisplayEventListAfterUndo, expectedDisplayTaskListAfterUndo);
		}


		TEST_METHOD(DisplayStubRetrieveEntryTest)
		{
			EntryType entryType = event;
			int taskID = 1;
			DisplayStub display;

			Entry* actualOldEntry;
			Entry* idealOldEntry;
			vector<Entry*> testEventList;

			string oldName = "Old Name";
			ptime t1;
			ptime t2;
			
			idealOldEntry = new Entry(oldName, t1, t2);
			testEventList.push_back(idealOldEntry);
			display.updateDisplayEventList(testEventList);

			actualOldEntry = display.retrieveEntry(entryType, taskID);
			
			string entryName = actualOldEntry->getTitle();

			Assert::AreEqual(actualOldEntry->getTitle(), oldName);
			
		}

		void getFeedback(vector<string>* feedback, Display* display) {
			*feedback = display->getCommandFeedback();
		}

		void assertStorageListSize(Storage* storage, EntryType type, size_t expectedSize) {
			
			size_t listSize;
			if (task == type) {
				listSize = (storage->getTaskList()).size();
			}
			else if (event == listSize) {
				listSize = (storage->getEventList()).size();
			}
			Assert::AreEqual(listSize, expectedSize);
		}

		void assertHistorySize(size_t expectedSize) {
			size_t historySize = History::getSize();
			Assert::AreEqual(historySize, expectedSize);
		}

		void checkTaskRestored(Storage* storage, Entry* taskToRestore) {
			Entry* actualTaskStored = (storage->getTaskList())[0];
			Assert::IsTrue(areEqual(actualTaskStored, taskToRestore, task));
		}

		void validateUndoFeedback(vector<string> feedbackAfterExecute, vector<string> feedbackAfterUndo) {
			
			vector<string>::iterator first = feedbackAfterExecute.begin();
			feedbackAfterExecute.insert(first, "Undone");
			
			Assert::AreEqual(feedbackAfterUndo.size(), feedbackAfterExecute.size());

			for (int i = 0; i < feedbackAfterUndo.size(); i++) {
				Assert::AreEqual(feedbackAfterUndo[i], feedbackAfterUndo[i]);
			}
		}

		void getDisplayTaskList(vector<Entry*>* taskListAfterUndo, Display* display) {
			*taskListAfterUndo = display->getTaskList();
		}

		void validateDisplayLists(Display* display, vector<Entry*> expectedEventList, vector<Entry*> expectedTaskList) {
			
			vector<Entry*> actualEventList = display->getEventList();
			vector<Entry*> actualTaskList = display->getEventList();
			Assert::IsTrue(areSameEntryList(actualEventList, expectedEventList, event));
			Assert::IsTrue(areSameEntryList(actualEventList, expectedTaskList, task));

		}

		bool areEqual(Entry* entry1, Entry* entry2, EntryType entryType) {
			if (entryType == event) {
				return(entry1->getTitle() == entry2->getTitle()
					&& entry1->getStartTime() == entry2->getStartTime()
					&& entry1->getEndTime() == entry2->getEndTime());
			}
			if (entryType == task) {
				return(entry1->getTitle() == entry2->getTitle()
					&& entry1->getStartTime() == entry2->getStartTime());
			}
		}

		bool areSameEntryList(vector<Entry*> list1, vector<Entry*> list2, EntryType entryType) {
			for (int i = 0; i < list2.size(); i++) {
				if (!areEqual(list1[i], list2[i], entryType)) {
					return false;
				}
			}
			return true;
		}
	};

}
```
###### Doowado - Task Manager\Doowado - Task Manager\AddCommand.cpp
``` cpp

const string AddCommand::MESSAGE_ADDED = "Added";


AddCommand::AddCommand(string entryTitle, ptime entryStartTime, ptime entryEndTime)
{
	_entryTitle = entryTitle;
	_entryStartTime = entryStartTime;
	_entryEndTime = entryEndTime;
}


AddCommand::~AddCommand()
{
}

void AddCommand::execute(Storage* data, Display *display) {
	checkValidTitle(_entryTitle);
	
	if (!_entryStartTime.is_not_a_date_time()) {
		//cout << "Event" << endl;
		entryType = type_event;
		_newEntry = new Entry(_entryTitle, _entryStartTime, _entryEndTime);
		data->addEvent(_newEntry);
	}
	else if (!_entryEndTime.is_not_a_date_time()) {
		//cout << "Task" << endl;
		entryType = type_timed_task;
		_newEntry = new Entry(_entryTitle, _entryEndTime);
		data->addTask(_newEntry);
	}
	else {
		//cout << "Floating Task" << endl;
		entryType = type_floating_task;
		_newEntry = new Entry(_entryTitle);
		data->addTask(_newEntry);
	}

	generateFeedback();
	updateDisplay(display, data);
	data->saveToFile();

	History::pushCommand(this);
}

void AddCommand::undo(Storage * data, Display * display)
{
	if (type_event == entryType) {
		data->deleteFromEventList(_newEntry);
	}
	else if (type_timed_task == entryType) {
		data->deleteFromTaskLIst(_newEntry);
	}
	else if (type_floating_task == entryType) {
		data->deleteFromTaskLIst(_newEntry);
	}
	_newEntry = NULL;
	generateUndoFeedback();
	updateDisplay(display, data);
}

void AddCommand::generateFeedback() {
	_feedback.push_back(MESSAGE_ADDED);
	_feedback.push_back(_entryTitle);

	if (type_event == entryType) {
		_feedback.push_back(to_simple_string(_entryStartTime));
		_feedback.push_back(to_simple_string(_entryEndTime));
	} else if (type_timed_task == entryType) {
		_feedback.push_back(to_simple_string(_entryEndTime));
	} else if (type_floating_task == entryType) {

	}

}

void AddCommand::checkValidTitle(string title)
{
	assert(title != "");
}

void AddCommand::updateDisplay(Display* display, Storage* data)
{
	vector<Entry*> relevantEventList;
	vector<Entry*> relevantTaskList;

	if (type_event == entryType) {
		data->retrieveByDate(_entryStartTime, relevantEventList, relevantTaskList);
	}
	else if (type_timed_task == entryType) {
		data->retrieveByDate(_entryEndTime, relevantEventList, relevantTaskList);
	}
	else if (type_floating_task == entryType) {
		ptime currentTime(second_clock::local_time());
		data->retrieveByDate(currentTime, relevantEventList, relevantTaskList);
	}

	display->updateDisplayEventList(relevantEventList);
	display->updateDisplayTaskList(relevantTaskList);

	display->updateCommandFeedback(_feedback);
	display->setLatestUpdatedEntry(_newEntry);

	
}

void AddCommand::generateUndoFeedback()
{
	vector<string>::iterator front = _feedback.begin();

	_feedback.insert(front, "Undone");
}

```
###### Doowado - Task Manager\Doowado - Task Manager\AddCommand.h
``` h

class AddCommand: public Command
{
private:
	static const enum EntryType { type_event, type_timed_task, type_floating_task };
	static const string MESSAGE_ADDED;

	string _entryTitle;
	ptime _entryStartTime;
	ptime _entryEndTime;

	vector<string> _feedback;

	EntryType entryType;
	Entry* _newEntry;

public:
	AddCommand(string entryTitle, ptime entryStartTime, ptime entryEndTime);
	~AddCommand();

	void execute(Storage* data, Display *display);
	void undo(Storage* data, Display* display);

	void generateFeedback();
	void checkValidTitle(string);

	void updateDisplay(Display*, Storage*);

	void generateUndoFeedback();
};

```
###### Doowado - Task Manager\Doowado - Task Manager\Command.cpp
``` cpp

Command::Command()
{
}


Command::~Command()
{
}

void Command::execute(Storage* data, Display* display) {

}

void Command::undo(Storage * data, Display * display) {

}
```
###### Doowado - Task Manager\Doowado - Task Manager\Command.h
``` h

#include <vector>
#include <string> 
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include "Storage.h"
#include "Display.h"
#include <assert.h>
#include "History.h"

using namespace std;
using namespace boost::gregorian;
using namespace boost::posix_time;

const string MESSAGE_SUCCESSFUL_UNDO = "Undone";

class Command
{
public:
	Command();
	virtual ~Command();

	virtual void execute(Storage* data, Display* display);
	virtual void undo(Storage* data, Display* display);
};

```
###### Doowado - Task Manager\Doowado - Task Manager\Display.cpp
``` cpp

Display::Display(){}


Display::~Display(){}

void Display::updateCommandFeedback(vector<string>& feedback)
{
	checkValidFeedback(feedback);
	_commandFeedback = feedback;
}

void Display::updateDisplayEventList(vector<Entry*>& updatedEventList)
{
	_eventList = updatedEventList;
}

void Display::updateDisplayTaskList(vector<Entry*>& updatedTaskList)
{
	_taskList = updatedTaskList;
}

```
###### Doowado - Task Manager\Doowado - Task Manager\Display.cpp
``` cpp
void Display::checkValidFeedback(vector<string>& feedback)
{
	assert(feedback.size() != 0);
}

vector<Entry*>& Display::getEventList()
{
	return _eventList;
}

vector<Entry*>& Display::getTaskList()
{
	return _taskList;
}

vector<string>& Display::getCommandFeedback()
{
	return _commandFeedback;
}


```
###### Doowado - Task Manager\Doowado - Task Manager\Display.h
``` h

class Display
{
protected:
	vector<string> _commandFeedback;
	vector<Entry*> _eventList;
	vector<Entry*> _taskList;
	
	string _eventDisplayState;
	string _taskDisplayState;

	Entry* _lastUpdatedEntry;

public:
	Display();
	~Display();
	
	//updateDefault
	void updateCommandFeedback(vector<string>&);
	void updateDisplayEventList(vector<Entry*>&);
	void updateDisplayTaskList(vector<Entry*>&);
	
	Entry* retrieveEntry(EntryType, int);
	void checkValidFeedback(vector<string>&);

	vector<Entry*>& getEventList();
	vector<Entry*>& getTaskList();
	vector<string>& getCommandFeedback();

```
###### Doowado - Task Manager\Doowado - Task Manager\History.cpp
``` cpp

stack<Command*> History::_commandStack;

History::History()
{
}


History::~History()
{
}

Command * History::getLastCommand()
{
	if (_commandStack.empty()) {
		return nullptr;
	}

	Command* lastReversibleCmd;
	lastReversibleCmd = _commandStack.top();
	_commandStack.pop();
	return lastReversibleCmd;
}

void History::pushCommand(Command* cmd)
{
	_commandStack.push(cmd);
}

void History::empty()
{
	while (!_commandStack.empty()) {
		_commandStack.pop();
	}
}
```
###### Doowado - Task Manager\Doowado - Task Manager\History.h
``` h

class Command;
#include <stack>
using namespace std;

class History
{
private:
	static stack<Command*> _commandStack;
public:

#ifdef TESTMODE
	static size_t getSize() {
		return _commandStack.size();
	}
#endif

	History();
	~History();

	static Command* getLastCommand();
	static void pushCommand(Command* cmd);
	static void empty();
};

```
###### Doowado - Task Manager\Doowado - Task Manager\UndoCommand.cpp
``` cpp

const string UndoCommand::MSG_NOTHING_TO_UNDO = "Nothing to undo";

UndoCommand::UndoCommand()
{
}


UndoCommand::~UndoCommand()
{
}

void UndoCommand::execute(Storage * data, Display * display)
{
	Command* lastReversibleCmd;
	lastReversibleCmd =  History::getLastCommand();

	if (doesNotExist(lastReversibleCmd)) {
		generateFailureFeedback();
		display->updateCommandFeedback(_feedback);
		return;
	}

	lastReversibleCmd->undo(data, display);
}

bool UndoCommand::doesNotExist(Command *cmd)
{
	return (NULL == cmd);
}

void UndoCommand::generateFailureFeedback()
{
	_feedback.push_back(MSG_NOTHING_TO_UNDO);
}
```
###### Doowado - Task Manager\Doowado - Task Manager\UndoCommand.h
``` h

class UndoCommand: public Command
{
#ifndef TESTMODE
private:
#else 
public:
#endif
	static const string MSG_NOTHING_TO_UNDO;
	vector<string> _feedback;
public:
	UndoCommand();
	~UndoCommand();

	void execute(Storage* data, Display* display);
	bool doesNotExist(Command*);
	void generateFailureFeedback();
};

```
###### Doowado - Task Manager\SystemTest\SystemTest.cpp
``` cpp
namespace SystemTest
{		
	//Test the execution of an add command from user input string to display
	//Pre-existing data is not read from a text file but directly hardcoded into storage
	TEST_CLASS(AddSingleTaskTest)
	{
	public:
		
		string taskName = "house cleaning";
		date testDate = date(2015, Nov, 10);
		ptime testStartTime;
		ptime testEndTime = ptime(testDate, hours(7));
		Entry testTask = Entry(taskName,testStartTime, testEndTime);

		Entry* sameDayEvent1;
		Entry* sameDayEvent2;
		Entry* futureDayEvent1;
		Entry* futureDayEvent2;

		Entry* sameDayTask1;
		Entry* floatingTask1;
		Entry* futureDayTask1;
		Entry* floatingTask2;

		// add a single task without initializing storage
		// validate the display
		TEST_METHOD(AddTask)
		{
			string userCommand = "add house cleaning on 10/11/2015 7";
			
			Logic logic;
			Display actualDisplay;
			Display idealDisplay;

			generateHardcodedDisplay(&idealDisplay);

			logic.initialiseProgram();
			logic.processCommand(userCommand);
			
			actualDisplay = *(logic.getDisplay());

			validateDisplay(actualDisplay, idealDisplay);
		}

		// initialize storage with a few hard-coded entries
		// add a single task 
		// validate the display
		TEST_METHOD(AddTasktoNonEmptyStorageTest)
		{			
			Logic logic;
			Display actualDisplay;
			Display idealDisplay;

			string userCommand = "add house cleaning on 10/11/2015 7";
			initializeHardcodedStorage(&logic);

			generateHardcodedDisplayForNonEmptyStorage(&idealDisplay);

			logic.processCommand(userCommand);

			actualDisplay = *(logic.getDisplay());

			validateDisplay(actualDisplay, idealDisplay);
		}

		void initializeHardcodedStorage(Logic* logic) {
			Storage* storage = logic->getStorage();
			vector<Entry*> hardcodedEventList;
			vector<Entry*> hardcodedTaskList;

			date futureDate = date(2015, Nov, 12);

			ptime sameDayStartTime1 = ptime(testDate, hours(1));
			ptime sameDayStartTime2 = ptime(testDate, hours(9));

			ptime sameDayEndTime1 = ptime(testDate, hours(2));
			ptime sameDayEndTime2 = ptime(testDate, hours(10));

			ptime futureDayStartTime1 = ptime(futureDate, hours(1));
			ptime futureDayStartTime2 = ptime(futureDate, hours(9));

			ptime futureDayEndTime1 = ptime(futureDate, hours(2));
			ptime futureDayEndTime2 = ptime(futureDate, hours(10));
			
			sameDayEvent1 = new Entry("sameDayEvent1", sameDayStartTime1, sameDayEndTime1);
			sameDayEvent2 = new Entry("sameDayEvent2", sameDayStartTime1, sameDayEndTime1);
			futureDayEvent1 = new Entry("futureDayEvent1", futureDayStartTime1, futureDayEndTime1);
			futureDayEvent2 = new Entry("futureDayEvent2", futureDayStartTime1, futureDayEndTime1);

			sameDayTask1 = new Entry("sameDayEvent1", sameDayEndTime1);
			floatingTask1 = new Entry("floatingTask1");
			futureDayTask1 = new Entry("futureDayEvent1", futureDayEndTime1);
			floatingTask2 = new Entry("floatingTask2");
			
			hardcodedEventList.push_back(sameDayEvent1);
			hardcodedEventList.push_back(sameDayEvent2);
			hardcodedEventList.push_back(futureDayEvent1);
			hardcodedEventList.push_back(futureDayEvent2);

			hardcodedTaskList.push_back(sameDayTask1);
			hardcodedTaskList.push_back(futureDayTask1);
			hardcodedTaskList.push_back(floatingTask1);
			hardcodedTaskList.push_back(floatingTask2);

			storage->setEventList(hardcodedEventList);
			storage->setTaskList(hardcodedTaskList);
		}

		void validateDisplay(Display actualDisplay, Display idealDisplay) {
			validateCmdFeedback(actualDisplay, idealDisplay);
			validateEventList(actualDisplay, idealDisplay);
			validateTaskList(actualDisplay, idealDisplay);
		}

		void generateHardcodedDisplay(Display* idealDisplay) {
			
			vector<string> idealCmdFeedback;
			vector<Entry*> idealDisplayEventList;
			vector<Entry*> idealDisplayTaskList;

			idealCmdFeedback.push_back("Added");
			idealCmdFeedback.push_back(taskName);
			idealCmdFeedback.push_back(to_simple_string(testEndTime));

			idealDisplayTaskList.push_back(&testTask);

			idealDisplay->updateCommandFeedback(idealCmdFeedback);
			idealDisplay->updateDisplayEventList(idealDisplayEventList);
			idealDisplay->updateDisplayTaskList(idealDisplayTaskList);
			return;
		}

		void generateHardcodedDisplayForNonEmptyStorage(Display* idealDisplay) {

			vector<string> idealCmdFeedback;
			vector<Entry*> idealDisplayEventList;
			vector<Entry*> idealDisplayTaskList;

			idealCmdFeedback.push_back("Added");
			idealCmdFeedback.push_back(taskName);
			idealCmdFeedback.push_back(to_simple_string(testEndTime));

			idealDisplayEventList.push_back(sameDayEvent1);
			idealDisplayEventList.push_back(sameDayEvent2);
			
			idealDisplayTaskList.push_back(sameDayTask1);
			idealDisplayTaskList.push_back(&testTask);
			idealDisplayTaskList.push_back(floatingTask1);
			idealDisplayTaskList.push_back(floatingTask2);

			idealDisplay->updateCommandFeedback(idealCmdFeedback);
			idealDisplay->updateDisplayEventList(idealDisplayEventList);
			idealDisplay->updateDisplayTaskList(idealDisplayTaskList);
			return;
		}

		void validateCmdFeedback(Display actualDisplay, Display idealDisplay) {
			
			vector<string> actualFeedback = actualDisplay.getCommandFeedback();
			vector<string> idealFeedback = idealDisplay.getCommandFeedback();

			Assert::IsTrue(areSameFeedback(actualFeedback, idealFeedback));

		}

		void validateEventList(Display actualDisplay, Display idealDisplay) {
			vector<Entry*> actualEventList = actualDisplay.getEventList();
			vector<Entry*> idealEventList = idealDisplay.getEventList();

			Assert::AreEqual(actualEventList.size(), idealEventList.size());
			Assert::IsTrue(areSameEntryList(actualEventList, idealEventList, event));
		}

		void validateTaskList(Display actualDisplay, Display idealDisplay) {
			vector<Entry*> actualTaskList = actualDisplay.getTaskList();
			vector<Entry*> idealTaskList = idealDisplay.getTaskList();

			Assert::AreEqual(actualTaskList.size(), idealTaskList.size());
			Assert::IsTrue(areSameEntryList(actualTaskList, idealTaskList, task));
		}

		bool areSameFeedback(vector<string> feedback1, vector<string> feedback2) {
			for (int i = 0; i < feedback2.size(); i++) {
				if (feedback1[i] != feedback2[i]) {
					return false;
				}
			}
			return true;
		}

		bool areSameEntry(Entry* entry1, Entry* entry2, EntryType entryType) {
			if (entryType == event) {
				return(entry1->getTitle() == entry2->getTitle()
					&& entry1->getStartTime() == entry2->getStartTime()
					&& entry1->getEndTime() == entry2->getEndTime());
			}
			if (entryType == task) {
				return(entry1->getTitle() == entry2->getTitle()
					&& entry1->getEndTime() == entry2->getEndTime()
					);
			}
		}

		bool areSameEntryList(vector<Entry*> list1, vector<Entry*> list2, EntryType entryType) {
			for (int i = 0; i < list2.size(); i++) {
				if (!areSameEntry(list1[i], list2[i], entryType)) {
					return false;
				}
			}
			return true;
		}

	};
}
```
