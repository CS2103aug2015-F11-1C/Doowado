# A0118890X
###### Doowado - Task Manager\Storage.cpp
``` cpp

const string EVENT_ENTRY = "Event";
const string TASK_ENTRY = "Task";
const string FTASK_ENTRY = "FTask";
const string EVENT_CLASHING = "Clashing";
const string EVENT_NOT_CLASHING = "Not Clashing";
const string TASK_COMPLETED = "Completed";
const string TASK_NOT_COMPLETED = "Not Completed";
const string TASK_OVERDUE = "Overdue";
const string TASK_NOT_OVERDUE = "Not Overdue";
const string TODAY_INDICATOR = "today";
const string TOMORROW_INDICATOR = "tomorrow";
const string HELP_DIRECTORY = "Help.txt";
const string SAVE_PATH_FILE_DIRECTORY = "SaveDir.txt";
const string DEFAULT_SAVE_PATH = "SaveFile.txt";
const string SEARCH_QUERY_NOT_FOUND = "Phrase not found in database";
const string EMPTY_STRING = "";

const string INVALID_SAVE_PATH_ERROR = "Save Path Invalid";

void checkEmptyVector(vector<Entry*> Result) {
	if (Result.empty()) {
		throw string(SEARCH_QUERY_NOT_FOUND);
	}
	else {
		return;
	}
}

void removeDuplicateEvents(vector<Entry*> Result) {
	vector <Entry*>::iterator it1;
	vector <Entry*>::iterator it2;
	
	for (it1 = Result.begin(); it1 != Result.end(); it1++) {
		for (it2 = it1 + 1; it2 != Result.end(); it2++) {
			if ((*it1) == (*it2)) {
				it2 = Result.erase(it2);
				if (it2 == Result.end()) {
					break;
				}
			}
		}
	}
}

void removeDuplicateTasks(vector<Entry*> Result) {
	vector <Entry*>::iterator it1;
	vector <Entry*>::iterator it2;

	for (it1 = Result.begin(); it1 != Result.end(); it1++) {
		for (it2 = it1 + 1; it2 != Result.end(); it2++) {
			if ((*it1) == (*it2)) {
				it2 = Result.erase(it2);
				if (it2 == Result.end()) {
					break;
				}
			}
		}
	}
}

Storage::Storage() {
	ifstream savePathInput(SAVE_PATH_FILE_DIRECTORY);
	getline(savePathInput, _saveDir);
	savePathInput.close();

	_helpDir = HELP_DIRECTORY;
}

void Storage::addEvent(Entry * newEvent) {
	if (_eventList.empty()) {
		_eventList.push_back(newEvent);
	}
	else {
		vector <Entry*>::iterator it = _eventList.begin();

		while (it != _eventList.end() && newEvent->getStartTime() > (*it)->getStartTime()) {
			it++;
		}

		if (it == _eventList.end()) {
			_eventList.push_back(newEvent);
		}
		else {
			_eventList.insert(it, newEvent);
		}
	}
}

void Storage::addTask(Entry * newTask) {
	if (_taskList.empty() || newTask->getEndTime().is_not_a_date_time()) {
		_taskList.push_back(newTask);
	}
	else {
		vector <Entry*>::iterator it = _taskList.begin();

		while (it != _taskList.end() && newTask->getEndTime() > (*it)->getEndTime()) {
			it++;
		}

		if (it == _taskList.end()) {
			_taskList.push_back(newTask);
		}
		else {
			_taskList.insert(it, newTask);
		}
	}
}

vector <Entry*> Storage::searchEventsByTitle(vector <string> keywords) {
	vector <Entry*> result;

	for (int i = 0; i < keywords.size(); i++) {
		string keyword = keywords[i];
		std::transform(keyword.begin(), keyword.end(), keyword.begin(), tolower);

		for (int j = 0; j < _eventList.size(); j++) {
			string currentName = _eventList[j]->getTitle();
			std::transform(currentName.begin(), currentName.end(), currentName.begin(), tolower);

			size_t found = currentName.find(keyword);
			if (found != string::npos) {
				result.push_back(_eventList[j]);
			}
		}
	}
	
	removeDuplicateEvents(result);
	return result;
}

vector <Entry*> Storage::searchTasksByTitle(vector <string> keywords) {
	vector <Entry*> result;

	for (int i = 0; i < keywords.size(); i++) {
		string keyword = keywords[i];
		std::transform(keyword.begin(), keyword.end(), keyword.begin(), tolower);

		for (int j = 0; j < _taskList.size(); j++) {
			string currentName = _taskList[j]->getTitle();
			std::transform(currentName.begin(), currentName.end(), currentName.begin(), tolower);

			size_t found = currentName.find(keyword);
			if (found != string::npos) {
				result.push_back(_taskList[j]);
			}
		}
	}

	removeDuplicateTasks(result);
	return result;
}


// Saves to txt file in the following format:
// Entry Type
// Attribute 1 of that Entry type
// Attribute 2 of that Entry type
// Attribute 3 of that Entry type (if any)
// Attribute 4 of that Entry type (if any)
// Attribute 5 of that Entry type (if any)
void Storage::saveToFile() {
	ofstream output;

	if (_saveDir == EMPTY_STRING) {
		_saveDir = DEFAULT_SAVE_PATH;
	}
	output.open(_saveDir);

	if (!output.is_open()) {
		StorageException errorMessage(SAVE_PATH_FILE_DIRECTORY);

		throw (errorMessage);
	}

	for (int i = 0; i < _eventList.size(); i++) {
		output << EVENT_ENTRY << endl;
		output << _eventList[i]->getTitle() << endl;
		output << to_iso_string(_eventList[i]->getStartTime()) << endl;
		output << to_iso_string(_eventList[i]->getEndTime()) << endl;
		if (_eventList[i]->isClash()) {
			output << EVENT_CLASHING << endl;
		} else {
			output << EVENT_NOT_CLASHING << endl;
		}
	}

	for (int i = 0; i < _taskList.size(); i++) {
		if (_taskList[i]->getEndTime().is_not_a_date_time()) {
			output << FTASK_ENTRY << endl;
		}
		else {
			output << TASK_ENTRY << endl;
		}
		output << _taskList[i]->getTitle() << endl;

		if (!_taskList[i]->getEndTime().is_not_a_date_time()) {
			output << to_iso_string(_taskList[i]->getEndTime()) << endl;
		}

		if (_taskList[i]->isDone()) {
			output << TASK_COMPLETED << endl;
		}
		else {
			output << TASK_NOT_COMPLETED << endl;
		}

		if (_taskList[i]->isOverdue()) {
			output << TASK_OVERDUE << endl;
		}
		else {
			output << TASK_NOT_OVERDUE << endl;
		}
	}
	output.close();

	//saves the directory of the txt file used to save
	ofstream savedir(SAVE_PATH_FILE_DIRECTORY);
	savedir << _saveDir << endl;
	savedir.close();
}

void Storage::loadFromFile() {
	ifstream input;

	if (_saveDir == EMPTY_STRING) {
		_saveDir = DEFAULT_SAVE_PATH;
	}
	input.open(_saveDir);

	if (!input.is_open()) {
		StorageException errorMessage(SAVE_PATH_FILE_DIRECTORY);

		throw (errorMessage);
	}

	string entryType;

	while (getline(input, entryType)) {
		if (entryType == EVENT_ENTRY) {
			string title;
			getline(input, title);

			string time;
			getline(input, time);
			ptime startTime(from_iso_string(time));
			getline(input, time);
			ptime endTime(from_iso_string(time));

			Entry *newEvent;
			newEvent = new Entry(title, startTime, endTime);

			string clashing;
			getline(input, clashing);
			if (clashing == EVENT_CLASHING) {
				newEvent->setClash(true);
			}

			_eventList.push_back(newEvent);
		}
		else if (entryType == TASK_ENTRY) {
			string title;
			getline(input, title);

			string time;
			getline(input, time);
			ptime dueTime(from_iso_string(time));

			bool isCompleted;
			string completed;
			getline(input, completed);
			if (completed == TASK_COMPLETED) {
				isCompleted = true;
			}
			else {
				isCompleted = false;
			}

			bool isOverdue;
			string overdue;
			getline(input, overdue);
			if (overdue == TASK_OVERDUE) {
				isOverdue = true;
			}
			else {
				isOverdue = false;
			}

			Entry *newTask;
			newTask = new Entry(title, dueTime);
			newTask->setDone(isCompleted);
			newTask->setOverdue(isOverdue);
			_taskList.push_back(newTask);
		}
		else if (entryType == FTASK_ENTRY) {
			string title;
			getline(input, title);

			bool isCompleted;
			string completed;
			getline(input, completed);
			if (completed == TASK_COMPLETED) {
				isCompleted = true;
			}
			else {
				isCompleted = false;
			}

			bool isOverdue = false;

			Entry *newFTask;
			newFTask = new Entry(title);
			newFTask->setDone(isCompleted);
			newFTask->setOverdue(isOverdue);
			_taskList.push_back(newFTask);
		}
	}

	input.close();
}

std::vector<Entry*> Storage::retrieveEventList()
{
	return _eventList;
}

std::vector<Entry*> Storage::retrieveTaskList()
{
	return _taskList;
}

void Storage::displayDefault(vector <Entry*> *eventDisplay, vector <Entry*> *taskDisplay) {
	ptime currentTime(second_clock::local_time());

	vector <Entry*>::iterator itE = eventDisplay->begin();

	for (int i = 0; i < _eventList.size(); i++) {

		ptime eventTime(_eventList[i]->getStartTime());
		if (eventTime.date() == currentTime.date()) {
			if (itE != eventDisplay->end()) {
				*itE = _eventList[i];
				itE++;
			}
			else {
				eventDisplay->push_back(_eventList[i]);
				itE = eventDisplay->end();
			}
		}
	}

	vector <Entry*>::iterator itT = taskDisplay->begin();

	for (int i = 0; i < _taskList.size(); i++) {
		if (!_taskList[i]->isDone() && !_taskList[i]->getEndTime().is_not_a_date_time()) {
			if (itT != taskDisplay->end()) {
				*itT = _taskList[i];
				itT++;
			}
			else {
				taskDisplay->push_back(_taskList[i]);
				itT = taskDisplay->end();
			}
		}
	}

	for (int i = 0; i < _taskList.size(); i++) {
		if (_taskList[i]->getEndTime().is_not_a_date_time() && !_taskList[i]->isDone()) {
			if (itT != taskDisplay->end()) {
				*itT = _taskList[i];
				itT++;
			}
			else {
				taskDisplay->push_back(_taskList[i]);
				itT = taskDisplay->end();
			}
		}
	}
}

void Storage::retrieveByDate(ptime timeIndicator, vector <Entry*>& eventResult, vector <Entry*>& taskResult) {
	
	eventResult.clear();
	taskResult.clear();

	for (int i = 0; i < _eventList.size(); i++) {
		if (_eventList[i]->getStartTime().date() <= timeIndicator.date() && _eventList[i]->getEndTime().date() >= timeIndicator.date()) {
			eventResult.push_back(_eventList[i]);
		}
	}

	for (int i = 0; i < _taskList.size(); i++) {
		if (_taskList[i]->getEndTime().date() == timeIndicator.date() || _taskList[i]->getEndTime().is_not_a_date_time()) {
			taskResult.push_back(_taskList[i]);
		}
	}
}


void Storage::retrieveByDate(ptime timeIndicator1, ptime timeIndicator2, vector<Entry*>& eventResult, vector<Entry*>& taskResult) {
	eventResult.clear();
	taskResult.clear();

	for (int i = 0; i < _eventList.size(); i++) {
		if ((_eventList[i]->getEndTime().date() >= timeIndicator1.date() && _eventList[i]->getEndTime().date() <= timeIndicator2.date()) || (_eventList[i]->getStartTime().date() <= timeIndicator2.date() && _eventList[i]->getStartTime().date() >= timeIndicator1.date())) {
			eventResult.push_back(_eventList[i]);
		}
		else if ((_eventList[i]->getEndTime().date() <= timeIndicator1.date() && _eventList[i]->getEndTime().date() >= timeIndicator2.date()) || (_eventList[i]->getStartTime().date() >= timeIndicator2.date() && _eventList[i]->getStartTime().date() <= timeIndicator1.date())) {
			eventResult.push_back(_eventList[i]);
		}
	}
	for (int i = 0; i < _taskList.size(); i++) {
		if ((_taskList[i]->getEndTime().date() >= timeIndicator1.date() && _taskList[i]->getEndTime().date() <= timeIndicator2.date()) || _taskList[i]->getEndTime().is_not_a_date_time()) {
			taskResult.push_back(_taskList[i]);
		}
	}
}

vector<Entry*> Storage::retrieveEventByDone(bool doneStatus)
{
	vector <Entry*> eventResult;

	for (int i = 0; i < _eventList.size(); i++) {
		if (_eventList[i]->isDone() == doneStatus) {
			eventResult.push_back(_eventList[i]);
		}
	}

	return eventResult;
}

vector<Entry*> Storage::retrieveTaskByDone(bool doneStatus)
{
	vector<Entry*> taskResult;

	for (int i = 0; i < _taskList.size(); i++) {
		if (_taskList[i]->isDone() == doneStatus) {
			taskResult.push_back(_taskList[i]);
		}
	}
	return taskResult;
}

vector<Entry*> Storage::retrieveTaskByOverdue(bool overdueStatus){
	vector <Entry*> taskResult;

	for (int i = 0; i < _taskList.size(); i++) {
		if (_taskList[i]->isOverdue() == overdueStatus && !_taskList[i]->isDone()) {
			taskResult.push_back(_taskList[i]);
		}
	}

	return taskResult;
}

void Storage::deleteFromEventList(Entry * eventPointer) {
	assert(eventPointer != NULL);

	vector<Entry*>::iterator it = _eventList.begin();

	while (*it != eventPointer) {
		it++;
	}

	_eventList.erase(it);
}

void Storage::deleteFromTaskLIst(Entry * taskPointer) {
	assert(taskPointer != NULL);

	vector<Entry*>::iterator it = _taskList.begin();

	while (*it != taskPointer) {
		it++;
	}

	_taskList.erase(it);
}

void Storage::changeSaveDirectory(string newSaveDir) {
	_saveDir = newSaveDir;
}
```
###### Doowado - Task Manager\Storage.h
``` h

#include "Entry.h"
#include "StorageException.h"
#include <vector>
#include <fstream>

enum EntryType { event, task };

class Storage {
protected:
	vector <Entry*> _eventList;
	vector <Entry*> _taskList;
	string _saveDir;
	string _helpDir;

public:
	Storage();

#ifdef TESTMODE
	vector<Entry*> getEventList() {
		return _eventList;
	}
	vector<Entry*>  getTaskList() {
		return _taskList;
	}
	void setEventList(vector<Entry*> hardcodedList) {
		_eventList = hardcodedList;
	}
	void setTaskList(vector<Entry*> hardcodedList) {
		_taskList = hardcodedList;
	}
#endif

	void addEvent(Entry* newEvent);
	void addTask(Entry* newTask);

	vector <Entry*> searchEventsByTitle(vector <string> keywords);
	vector <Entry*> searchTasksByTitle(vector <string> keywords);

	void displayDefault(vector <Entry*> *eventList, vector <Entry*> *taskList);				// Display today's event and all uncompleted tasks
	void retrieveByDate(ptime timeIndicator, vector<Entry*>& eventResult, vector<Entry*>& taskResult);
	void retrieveByDate(ptime timeIndicator1, ptime timeIndicator2, vector<Entry*>& eventResult, vector<Entry*>& taskResult);
	
	vector<Entry*> retrieveEventByDone(bool doneStatus);
	vector<Entry*> retrieveTaskByDone(bool doneStatus);
	vector<Entry*> retrieveTaskByOverdue(bool overdueStatus);
	void deleteFromEventList(Entry* eventPointer);
	void deleteFromTaskLIst(Entry* taskPointer);

	void changeSaveDirectory(string newSaveDir);

	void saveToFile();
	void loadFromFile();

	std::vector<Entry*> retrieveEventList();
	std::vector<Entry*> retrieveTaskList();
};
```
###### Doowado GUI\DisplayController.cpp
``` cpp

const string EVENT_SEARCH_FEEDBACK = "Showing Events with: ";
const string TASK_SEARCH_FEEDBACK = "Showing Tasks with: ";
const string EVENT_SHOW_DATE_FEEDBACK = "Showing Events on ";
const string TASK_SHOW_DATE_FEEDBACK = "Showing Tasks on ";
const string TASK_INCOMPLETE_OVERDUE_FEEDBACK = "Showing Tasks: ";
const char DOUBLE_QUOTE_CHARACTER = (char)34;
const string TASK_OVERDUE = "overdue";
const string TASK_INCOMPLETE = "incomplete";
const string TASK_COMPLETED = "completed";
const string EMPTY_STRING = "";
const string EVENT_DEFAULT_FEEDBACK = "today";
const string TASK_DEFAULT_FEEDBACK = "incomplete";
const string DEFAULT_ERROR_MESSAGE = "This input is not supported";

System::String^ convertToSystemString(std::string inputString) {
	return gcnew System::String(inputString.c_str());
}

std::string convertToStdString(System::String^ inputString) {
	return msclr::interop::marshal_as< std::string >(inputString);
}

void changeItemTitleFont(System::Windows::Forms::ListViewItem^ newListViewItem, Entry* currentEntry, Entry* lastUpdatedEntry) {
	if (currentEntry == lastUpdatedEntry) {
		newListViewItem->Font = (gcnew System::Drawing::Font(L"Microsoft Sans Serif", 13, System::Drawing::FontStyle::Bold, System::Drawing::GraphicsUnit::Pixel));
	}
	else {
		newListViewItem->Font = (gcnew System::Drawing::Font(L"Microsoft Sans Serif", 13, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Pixel));
	}
}

void changeItemDateFont(System::Windows::Forms::ListViewItem ^ newListViewItem, Entry * currentEntry, Entry* lastUpdatedEntry){
	if (currentEntry == lastUpdatedEntry) {
		newListViewItem->Font = (gcnew System::Drawing::Font(L"Microsoft Sans Serif", 10, System::Drawing::FontStyle::Bold, System::Drawing::GraphicsUnit::Pixel));
	}
	else {
		newListViewItem->Font = (gcnew System::Drawing::Font(L"Microsoft Sans Serif", 10, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Pixel));
	}
}

void changeEventColourByStatus(System::Windows::Forms::ListViewItem ^ newListViewItem, Entry * currentEvent){
	if (currentEvent->isDone()) {
		newListViewItem->ForeColor = System::Drawing::Color::Gray;
	}
	else if (currentEvent->isClash()) {
		newListViewItem->ForeColor = System::Drawing::Color::Orange;
	}
}

void changeTaskColourByStatus(System::Windows::Forms::ListViewItem ^ newListViewItem, Entry * currentTask)
{
	if (currentTask->isDone()) {
		newListViewItem->ForeColor = System::Drawing::Color::Gray;
	}
	else if (currentTask->isOverdue()) {
		newListViewItem->ForeColor = System::Drawing::Color::DarkRed;
	}
}

DisplayController::DisplayController(){
	_logic = new Logic;
}

DisplayController::~DisplayController() {
	delete _logic;
}

void DisplayController::initialiseProgram() {
	_logic->initialiseProgram();
}

void DisplayController::processInput(System::String^ inputString){
	std::string stdInput = convertToStdString(inputString);

	try {
		_logic->processCommand(stdInput);
	}
	catch (std::exception &e) {
		System::String^ errorMessage = convertToSystemString(e.what());

		throw (errorMessage);
	}
	catch (CmdBuilderException &e) {
		System::String^ errorMessage = convertToSystemString(e.getMessage());

		throw (errorMessage);
	}
	catch (CommandException &e) {
		System::String^ errorMessage = convertToSystemString(e.getMessage());

		throw (errorMessage);
	}
	catch (StorageException &e) {
		System::String^ errorMessage = convertToSystemString(e.getMessage());

		throw (errorMessage);
	}
	catch (...) {
		throw (DEFAULT_ERROR_MESSAGE);
	}
}

int DisplayController::getEventListSize() {
	return _logic->getDisplay()->getEventList().size();
}

int DisplayController::getTaskListSize() {
	return _logic->getDisplay()->getTaskList().size();
}

int DisplayController::getFeedbackListSize() {
	return _logic->getDisplay()->getCommandFeedback().size();
}

System::String ^ DisplayController::retrieveLastFeedback(){
	string lastFeedback;

	for (int i = 0; i < _logic->getDisplay()->getCommandFeedback().size(); i++) {
		lastFeedback += _logic->getDisplay()->getCommandFeedback().at(i);
		lastFeedback += " ";
	}

	System::String^ systemFeedback = convertToSystemString(lastFeedback);
	
	return systemFeedback;
}

System::String ^ DisplayController::retrieveEventListFeedback(){
	std::string feedback = _logic->getDisplay()->getEventDisplayState();

	if (feedback == EMPTY_STRING) {
		feedback = EVENT_DEFAULT_FEEDBACK;
	}
	
	//if start with quote its a search
	if (feedback[0] == DOUBLE_QUOTE_CHARACTER) {
		return convertToSystemString(EVENT_SEARCH_FEEDBACK + feedback);
	}
	else {
		return convertToSystemString(EVENT_SHOW_DATE_FEEDBACK + feedback);
	}
	
}

System::String ^ DisplayController::retrieveTaskListFeedback(){
	std::string feedback = _logic->getDisplay()->getTaskDisplayState();

	if (feedback == EMPTY_STRING) {
		feedback = TASK_DEFAULT_FEEDBACK;
	}

	//if start with quote its a search
	if (feedback[0] == DOUBLE_QUOTE_CHARACTER) {
		return convertToSystemString(TASK_SEARCH_FEEDBACK + feedback);
	}
	else if (feedback == TASK_OVERDUE || feedback == TASK_INCOMPLETE || feedback == TASK_COMPLETED){
		return convertToSystemString(TASK_INCOMPLETE_OVERDUE_FEEDBACK + feedback);
	}
	else {
		return convertToSystemString(TASK_SHOW_DATE_FEEDBACK + feedback);
	}
}

System::Windows::Forms::ListViewItem ^ DisplayController::retrieveEventNameFromList(int index){
	System::String^ eventID;
	System::String^ eventDetails;
	System::Windows::Forms::ListViewItem^ newListViewItem;

	Entry* currentEvent;

	currentEvent = _logic->getDisplay()->retrieveEntry(event, index);

	//process eventID
	eventID = convertToSystemString("E" + to_string(index + 1));

	//process eventTitle
	std::string title = currentEvent->getTitle();
	eventDetails = convertToSystemString(title);

	newListViewItem = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^>(2) { eventID, eventDetails }, -1));
	
	changeItemTitleFont(newListViewItem, currentEvent, _logic->getDisplay()->retrieveLastUpdatedEntry());

	changeEventColourByStatus(newListViewItem, currentEvent);
	
	return newListViewItem;
}

System::Windows::Forms::ListViewItem ^ DisplayController::retrieveEventStartFromList(int index){
	System::String^ eventID;
	System::String^ eventDetails;
	System::Windows::Forms::ListViewItem^ newListViewItem;

	Entry* currentEvent;

	currentEvent = _logic->getDisplay()->retrieveEntry(event, index);

	//process eventID
	eventID = convertToSystemString("");

	//process start time
	std::string startTime = to_simple_string(currentEvent->getStartTime());
	eventDetails = convertToSystemString("Start at: " + startTime);

	newListViewItem = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^>(2) { eventID, eventDetails }, -1));
	
	changeItemDateFont(newListViewItem, currentEvent, _logic->getDisplay()->retrieveLastUpdatedEntry());

	changeEventColourByStatus(newListViewItem, currentEvent);

	return newListViewItem;
}

System::Windows::Forms::ListViewItem ^ DisplayController::retrieveEventEndFromList(int index){
	System::String^ eventID;
	System::String^ eventDetails;
	System::Windows::Forms::ListViewItem^ newListViewItem;

	Entry* currentEvent;

	currentEvent = _logic->getDisplay()->retrieveEntry(event, index);

	//process eventID
	eventID = convertToSystemString("");

	//process end Time
	std::string endTime = to_simple_string(currentEvent->getEndTime());
	eventDetails = convertToSystemString("End at: "+ endTime);

	newListViewItem = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^>(2) { eventID, eventDetails }, -1));
	
	changeItemDateFont(newListViewItem, currentEvent, _logic->getDisplay()->retrieveLastUpdatedEntry());

	changeEventColourByStatus(newListViewItem, currentEvent);

	return newListViewItem;
}

System::Windows::Forms::ListViewItem ^ DisplayController::retrieveTaskNameFromList(int index){
	System::String^ taskID;
	System::String^ taskDetails;
	System::Windows::Forms::ListViewItem^ newListViewItem;

	Entry* currentTask;

	currentTask = _logic->getDisplay()->retrieveEntry(task, index);

	//process taskID
	taskID = convertToSystemString("T" + to_string(index + 1));

	//process taskTitle
	std::string title = currentTask->getTitle();
	taskDetails = convertToSystemString(title);

	newListViewItem = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^>(2) { taskID, taskDetails }, -1));

	changeItemTitleFont(newListViewItem, currentTask, _logic->getDisplay()->retrieveLastUpdatedEntry());

	changeTaskColourByStatus(newListViewItem, currentTask);

	return newListViewItem;
}

System::Windows::Forms::ListViewItem ^ DisplayController::retrieveTaskDueFromList(int index){
	System::String^ taskID;
	System::String^ taskDetails;
	System::Windows::Forms::ListViewItem^ newListViewItem;

	Entry* currentTask;

	currentTask = _logic->getDisplay()->retrieveEntry(task, index);

	//process eventID
	taskID = convertToSystemString("");

	//process end Time
	if (currentTask->getEndTime().is_not_a_date_time()) {
		return (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^>(1) { taskID }, -1));
	}
	else {
		std::string endTime = to_simple_string(currentTask->getEndTime());
		taskDetails = convertToSystemString("Due by: " + endTime);
		newListViewItem = (gcnew System::Windows::Forms::ListViewItem(gcnew cli::array< System::String^>(2) { taskID, taskDetails }, -1));

		changeItemDateFont(newListViewItem, currentTask, _logic->getDisplay()->retrieveLastUpdatedEntry());

		changeTaskColourByStatus(newListViewItem, currentTask);

		return newListViewItem;
	}

}

```
###### Doowado GUI\DisplayController.h
``` h

#include "Logic.h"
#include "CmdBuilderException.h"
#include "CommandException.h"
#include <msclr/marshal_cppstd.h>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

class DisplayController {
private:
	Logic *_logic;

public:
	DisplayController();
	~DisplayController();

	void initialiseProgram();

	void processInput(System::String^ inputString);
	int getEventListSize();
	int getTaskListSize();
	int getFeedbackListSize();

	System::String^ retrieveLastFeedback();
	System::String^ retrieveEventListFeedback();
	System::String^ retrieveTaskListFeedback();

	System::Windows::Forms::ListViewItem^ retrieveEventNameFromList(int index);
	System::Windows::Forms::ListViewItem^ retrieveEventStartFromList(int index);
	System::Windows::Forms::ListViewItem^ retrieveEventEndFromList(int index);

	System::Windows::Forms::ListViewItem^ retrieveTaskNameFromList(int index);
	System::Windows::Forms::ListViewItem^ retrieveTaskDueFromList(int index);
};
```
###### Doowado GUI\GUI.cpp
``` cpp

using namespace System;
using namespace System::Windows::Forms;

[STAThread]
int _stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false);

	DoowadoGUI::GUI mainWindow;
	Application::Run(%mainWindow);

	return 0;
}
```
###### Doowado GUI\GUI.h
``` h

#include <vector>
#include <algorithm>
#include <string>
#include <sstream>
#include "msclr\marshal_cppstd.h"
#include "DisplayController.h"
#include "HelpGUI.h"

namespace DoowadoGUI {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	DisplayController* Controller;

	/// <summary>
	/// Summary for GUI
	/// </summary>
	public ref class GUI : public MetroFramework::Forms::MetroForm {
	public:
		GUI(void)
		{
			InitializeComponent();

			//initializing program
			Controller = new DisplayController;
			Controller->initialiseProgram();
			updateGUI();

			this->FocusMe();
		}
		 
	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~GUI()
		{
			if (components)
			{
				delete components;
			}
		}

	private: System::Windows::Forms::ListView^  EventListDisplay;
	private: System::Windows::Forms::ColumnHeader^  EventID;
	private: System::Windows::Forms::ColumnHeader^  EventDesc;

	private: System::Windows::Forms::ListView^  TaskListDisplay;
	private: System::Windows::Forms::ColumnHeader^  TaskID;
	private: System::Windows::Forms::ColumnHeader^  TaskDescription;

	private: MetroFramework::Controls::MetroLabel^  EventListLabel;
	private: MetroFramework::Controls::MetroLabel^  TaskListLabel;

	private: MetroFramework::Controls::MetroTextBox^  inputBox;
	private: MetroFramework::Controls::MetroLabel^  feedbackLabel;
	private: MetroFramework::Controls::MetroTextBox^  FeedbackDisplay;

	private: System::Windows::Forms::Timer^  timer1;
	private: System::Windows::Forms::Label^  dateLabel;
	private: System::Windows::Forms::Label^  clockLabel;

	private: System::ComponentModel::IContainer^  components;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>


#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			this->components = (gcnew System::ComponentModel::Container());
			this->EventListDisplay = (gcnew System::Windows::Forms::ListView());
			this->EventID = (gcnew System::Windows::Forms::ColumnHeader());
			this->EventDesc = (gcnew System::Windows::Forms::ColumnHeader());
			this->TaskListDisplay = (gcnew System::Windows::Forms::ListView());
			this->TaskID = (gcnew System::Windows::Forms::ColumnHeader());
			this->TaskDescription = (gcnew System::Windows::Forms::ColumnHeader());
			this->EventListLabel = (gcnew MetroFramework::Controls::MetroLabel());
			this->TaskListLabel = (gcnew MetroFramework::Controls::MetroLabel());
			this->inputBox = (gcnew MetroFramework::Controls::MetroTextBox());
			this->feedbackLabel = (gcnew MetroFramework::Controls::MetroLabel());
			this->FeedbackDisplay = (gcnew MetroFramework::Controls::MetroTextBox());
			this->timer1 = (gcnew System::Windows::Forms::Timer(this->components));
			this->dateLabel = (gcnew System::Windows::Forms::Label());
			this->clockLabel = (gcnew System::Windows::Forms::Label());
			this->SuspendLayout();
			// 
			// EventListDisplay
			// 
			this->EventListDisplay->Anchor = System::Windows::Forms::AnchorStyles::None;
			this->EventListDisplay->BackColor = System::Drawing::Color::White;
			this->EventListDisplay->BorderStyle = System::Windows::Forms::BorderStyle::FixedSingle;
			this->EventListDisplay->Columns->AddRange(gcnew cli::array< System::Windows::Forms::ColumnHeader^  >(2) { this->EventID, this->EventDesc });
			this->EventListDisplay->ForeColor = System::Drawing::Color::Black;
			this->EventListDisplay->HeaderStyle = System::Windows::Forms::ColumnHeaderStyle::Nonclickable;
			this->EventListDisplay->Location = System::Drawing::Point(8, 80);
			this->EventListDisplay->Name = L"EventListDisplay";
			this->EventListDisplay->ShowItemToolTips = true;
			this->EventListDisplay->Size = System::Drawing::Size(317, 287);
			this->EventListDisplay->TabIndex = 0;
			this->EventListDisplay->UseCompatibleStateImageBehavior = false;
			this->EventListDisplay->View = System::Windows::Forms::View::Details;
			this->EventListDisplay->KeyDown += gcnew System::Windows::Forms::KeyEventHandler(this, &GUI::generalForm_KeyDown);
			this->EventListDisplay->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &GUI::generalForm_KeyPress);
			// 
			// EventID
			// 
			this->EventID->Text = L"ID.";
			this->EventID->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			this->EventID->Width = 35;
			// 
			// EventDesc
			// 
			this->EventDesc->Text = L"Event Description";
			this->EventDesc->Width = 265;
			// 
			// TaskListDisplay
			// 
			this->TaskListDisplay->Anchor = System::Windows::Forms::AnchorStyles::None;
			this->TaskListDisplay->BackColor = System::Drawing::Color::White;
			this->TaskListDisplay->BorderStyle = System::Windows::Forms::BorderStyle::FixedSingle;
			this->TaskListDisplay->Columns->AddRange(gcnew cli::array< System::Windows::Forms::ColumnHeader^  >(2) { this->TaskID, this->TaskDescription });
			this->TaskListDisplay->ForeColor = System::Drawing::Color::Black;
			this->TaskListDisplay->HeaderStyle = System::Windows::Forms::ColumnHeaderStyle::Nonclickable;
			this->TaskListDisplay->Location = System::Drawing::Point(331, 80);
			this->TaskListDisplay->Name = L"TaskListDisplay";
			this->TaskListDisplay->ShowItemToolTips = true;
			this->TaskListDisplay->Size = System::Drawing::Size(317, 287);
			this->TaskListDisplay->TabIndex = 0;
			this->TaskListDisplay->UseCompatibleStateImageBehavior = false;
			this->TaskListDisplay->View = System::Windows::Forms::View::Details;
			this->TaskListDisplay->KeyDown += gcnew System::Windows::Forms::KeyEventHandler(this, &GUI::generalForm_KeyDown);
			this->TaskListDisplay->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &GUI::generalForm_KeyPress);
			// 
			// TaskID
			// 
			this->TaskID->Text = L"ID.";
			this->TaskID->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			this->TaskID->Width = 35;
			// 
			// TaskDescription
			// 
			this->TaskDescription->Text = L"Task Description";
			this->TaskDescription->Width = 265;
			// 
			// EventListLabel
			// 
			this->EventListLabel->Anchor = System::Windows::Forms::AnchorStyles::None;
			this->EventListLabel->AutoSize = true;
			this->EventListLabel->FontSize = MetroFramework::MetroLabelSize::Small;
			this->EventListLabel->FontWeight = MetroFramework::MetroLabelWeight::Regular;
			this->EventListLabel->ForeColor = System::Drawing::Color::DarkTurquoise;
			this->EventListLabel->Location = System::Drawing::Point(8, 60);
			this->EventListLabel->Name = L"EventListLabel";
			this->EventListLabel->Size = System::Drawing::Size(124, 15);
			this->EventListLabel->Style = MetroFramework::MetroColorStyle::Silver;
			this->EventListLabel->TabIndex = 0;
			this->EventListLabel->Text = L"Your Events for Today:";
			this->EventListLabel->Theme = MetroFramework::MetroThemeStyle::Dark;
			this->EventListLabel->UseCustomBackColor = true;
			this->EventListLabel->UseCustomForeColor = true;
			this->EventListLabel->UseStyleColors = true;
			// 
			// TaskListLabel
			// 
			this->TaskListLabel->Anchor = System::Windows::Forms::AnchorStyles::None;
			this->TaskListLabel->AutoSize = true;
			this->TaskListLabel->FontSize = MetroFramework::MetroLabelSize::Small;
			this->TaskListLabel->FontWeight = MetroFramework::MetroLabelWeight::Regular;
			this->TaskListLabel->ForeColor = System::Drawing::Color::DarkTurquoise;
			this->TaskListLabel->Location = System::Drawing::Point(330, 60);
			this->TaskListLabel->Name = L"TaskListLabel";
			this->TaskListLabel->Size = System::Drawing::Size(112, 15);
			this->TaskListLabel->Style = MetroFramework::MetroColorStyle::White;
			this->TaskListLabel->TabIndex = 0;
			this->TaskListLabel->Text = L"Your Pending Tasks:";
			this->TaskListLabel->Theme = MetroFramework::MetroThemeStyle::Dark;
			this->TaskListLabel->UseCustomBackColor = true;
			this->TaskListLabel->UseCustomForeColor = true;
			this->TaskListLabel->UseStyleColors = true;
			// 
			// inputBox
			// 
			this->inputBox->Anchor = System::Windows::Forms::AnchorStyles::None;
			// 
			// 
			// 
			this->inputBox->CustomButton->Image = nullptr;
			this->inputBox->CustomButton->Location = System::Drawing::Point(618, 1);
			this->inputBox->CustomButton->Name = L"";
			this->inputBox->CustomButton->Size = System::Drawing::Size(21, 21);
			this->inputBox->CustomButton->Style = MetroFramework::MetroColorStyle::Blue;
			this->inputBox->CustomButton->TabIndex = 1;
			this->inputBox->CustomButton->Theme = MetroFramework::MetroThemeStyle::Light;
			this->inputBox->CustomButton->UseSelectable = true;
			this->inputBox->CustomButton->Visible = false;
			this->inputBox->Lines = gcnew cli::array< System::String^  >(1) { L"Enter Command Here" };
			this->inputBox->Location = System::Drawing::Point(8, 418);
			this->inputBox->MaxLength = 32767;
			this->inputBox->Name = L"inputBox";
			this->inputBox->PasswordChar = '\0';
			this->inputBox->ScrollBars = System::Windows::Forms::ScrollBars::None;
			this->inputBox->SelectedText = L"";
			this->inputBox->SelectionLength = 0;
			this->inputBox->SelectionStart = 0;
			this->inputBox->Size = System::Drawing::Size(640, 23);
			this->inputBox->Style = MetroFramework::MetroColorStyle::Orange;
			this->inputBox->TabIndex = 1;
			this->inputBox->Text = L"Enter Command Here";
			this->inputBox->Theme = MetroFramework::MetroThemeStyle::Dark;
			this->inputBox->UseSelectable = true;
			this->inputBox->UseStyleColors = true;
			this->inputBox->WaterMarkColor = System::Drawing::Color::FromArgb(static_cast<System::Int32>(static_cast<System::Byte>(109)), static_cast<System::Int32>(static_cast<System::Byte>(109)),
				static_cast<System::Int32>(static_cast<System::Byte>(109)));
			this->inputBox->WaterMarkFont = (gcnew System::Drawing::Font(L"Segoe UI", 12, System::Drawing::FontStyle::Italic, System::Drawing::GraphicsUnit::Pixel));
			this->inputBox->TextChanged += gcnew System::EventHandler(this, &GUI::inputBox_TextChanged);
			this->inputBox->DoubleClick += gcnew System::EventHandler(this, &GUI::inputBox_DoubleClick);
			this->inputBox->Enter += gcnew System::EventHandler(this, &GUI::inputBox_Enter);
			this->inputBox->KeyDown += gcnew System::Windows::Forms::KeyEventHandler(this, &GUI::inputBox_KeyDown);
			this->inputBox->Leave += gcnew System::EventHandler(this, &GUI::inputBox_Leave);
			// 
			// feedbackLabel
			// 
			this->feedbackLabel->Anchor = System::Windows::Forms::AnchorStyles::None;
			this->feedbackLabel->AutoSize = true;
			this->feedbackLabel->FontSize = MetroFramework::MetroLabelSize::Small;
			this->feedbackLabel->FontWeight = MetroFramework::MetroLabelWeight::Regular;
			this->feedbackLabel->ForeColor = System::Drawing::SystemColors::ControlDarkDark;
			this->feedbackLabel->Location = System::Drawing::Point(8, 400);
			this->feedbackLabel->Name = L"feedbackLabel";
			this->feedbackLabel->Size = System::Drawing::Size(258, 15);
			this->feedbackLabel->Style = MetroFramework::MetroColorStyle::Orange;
			this->feedbackLabel->TabIndex = 19;
			this->feedbackLabel->Text = L"add / edit / show / search / delete / undo / save";
			this->feedbackLabel->TextAlign = System::Drawing::ContentAlignment::MiddleCenter;
			this->feedbackLabel->Theme = MetroFramework::MetroThemeStyle::Light;
			this->feedbackLabel->UseCustomBackColor = true;
			this->feedbackLabel->UseCustomForeColor = true;
			this->feedbackLabel->UseStyleColors = true;
			// 
			// FeedbackDisplay
			// 
			this->FeedbackDisplay->Anchor = System::Windows::Forms::AnchorStyles::None;
			// 
			// 
			// 
			this->FeedbackDisplay->CustomButton->Image = nullptr;
			this->FeedbackDisplay->CustomButton->Location = System::Drawing::Point(618, 2);
			this->FeedbackDisplay->CustomButton->Name = L"";
			this->FeedbackDisplay->CustomButton->Size = System::Drawing::Size(19, 19);
			this->FeedbackDisplay->CustomButton->Style = MetroFramework::MetroColorStyle::Blue;
			this->FeedbackDisplay->CustomButton->TabIndex = 1;
			this->FeedbackDisplay->CustomButton->Theme = MetroFramework::MetroThemeStyle::Light;
			this->FeedbackDisplay->CustomButton->UseSelectable = true;
			this->FeedbackDisplay->CustomButton->Visible = false;
			this->FeedbackDisplay->Lines = gcnew cli::array< System::String^  >(0);
			this->FeedbackDisplay->Location = System::Drawing::Point(8, 373);
			this->FeedbackDisplay->MaxLength = 32767;
			this->FeedbackDisplay->Multiline = true;
			this->FeedbackDisplay->Name = L"FeedbackDisplay";
			this->FeedbackDisplay->PasswordChar = '\0';
			this->FeedbackDisplay->ReadOnly = true;
			this->FeedbackDisplay->ScrollBars = System::Windows::Forms::ScrollBars::Vertical;
			this->FeedbackDisplay->SelectedText = L"";
			this->FeedbackDisplay->SelectionLength = 0;
			this->FeedbackDisplay->SelectionStart = 0;
			this->FeedbackDisplay->Size = System::Drawing::Size(640, 24);
			this->FeedbackDisplay->Style = MetroFramework::MetroColorStyle::Orange;
			this->FeedbackDisplay->TabIndex = 2;
			this->FeedbackDisplay->Theme = MetroFramework::MetroThemeStyle::Dark;
			this->FeedbackDisplay->UseCustomForeColor = true;
			this->FeedbackDisplay->UseSelectable = true;
			this->FeedbackDisplay->UseStyleColors = true;
			this->FeedbackDisplay->WaterMarkColor = System::Drawing::Color::FromArgb(static_cast<System::Int32>(static_cast<System::Byte>(109)),
				static_cast<System::Int32>(static_cast<System::Byte>(109)), static_cast<System::Int32>(static_cast<System::Byte>(109)));
			this->FeedbackDisplay->WaterMarkFont = (gcnew System::Drawing::Font(L"Segoe UI", 12, System::Drawing::FontStyle::Italic, System::Drawing::GraphicsUnit::Pixel));
			this->FeedbackDisplay->KeyDown += gcnew System::Windows::Forms::KeyEventHandler(this, &GUI::generalForm_KeyDown);
			this->FeedbackDisplay->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &GUI::generalForm_KeyPress);
			// 
			// timer1
			// 
			this->timer1->Enabled = true;
			this->timer1->Tick += gcnew System::EventHandler(this, &GUI::timer1_Tick);
			// 
			// dateLabel
			// 
			this->dateLabel->Anchor = System::Windows::Forms::AnchorStyles::None;
			this->dateLabel->AutoSize = true;
			this->dateLabel->Font = (gcnew System::Drawing::Font(L"Cambria", 12, System::Drawing::FontStyle::Bold, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->dateLabel->ForeColor = System::Drawing::SystemColors::ControlLight;
			this->dateLabel->Location = System::Drawing::Point(328, 18);
			this->dateLabel->Name = L"dateLabel";
			this->dateLabel->Size = System::Drawing::Size(111, 19);
			this->dateLabel->TabIndex = 0;
			this->dateLabel->Text = L"Current Date";
			this->dateLabel->TextAlign = System::Drawing::ContentAlignment::MiddleCenter;
			// 
			// clockLabel
			// 
			this->clockLabel->Anchor = System::Windows::Forms::AnchorStyles::None;
			this->clockLabel->AutoSize = true;
			this->clockLabel->Font = (gcnew System::Drawing::Font(L"Cambria", 12, System::Drawing::FontStyle::Bold, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->clockLabel->ForeColor = System::Drawing::SystemColors::ControlLight;
			this->clockLabel->Location = System::Drawing::Point(515, 17);
			this->clockLabel->Name = L"clockLabel";
			this->clockLabel->Size = System::Drawing::Size(113, 19);
			this->clockLabel->TabIndex = 0;
			this->clockLabel->Text = L"Current Time";
			this->clockLabel->TextAlign = System::Drawing::ContentAlignment::MiddleCenter;
			// 
			// GUI
			// 
			this->AutoScaleDimensions = System::Drawing::SizeF(7, 15);
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
			this->AutoSize = true;
			this->AutoValidate = System::Windows::Forms::AutoValidate::EnablePreventFocusChange;
			this->BackgroundImageLayout = System::Windows::Forms::ImageLayout::Stretch;
			this->BorderStyle = MetroFramework::Forms::MetroFormBorderStyle::FixedSingle;
			this->CausesValidation = false;
			this->ClientSize = System::Drawing::Size(657, 451);
			this->Controls->Add(this->clockLabel);
			this->Controls->Add(this->dateLabel);
			this->Controls->Add(this->FeedbackDisplay);
			this->Controls->Add(this->feedbackLabel);
			this->Controls->Add(this->inputBox);
			this->Controls->Add(this->TaskListLabel);
			this->Controls->Add(this->EventListLabel);
			this->Controls->Add(this->TaskListDisplay);
			this->Controls->Add(this->EventListDisplay);
			this->Font = (gcnew System::Drawing::Font(L"Microsoft Sans Serif", 9, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->ForeColor = System::Drawing::SystemColors::HighlightText;
			this->HelpButton = true;
			this->MaximizeBox = false;
			this->Name = L"GUI";
			this->Resizable = false;
			this->Style = MetroFramework::MetroColorStyle::Orange;
			this->Text = L"Doowado";
			this->Theme = MetroFramework::MetroThemeStyle::Dark;
			this->KeyDown += gcnew System::Windows::Forms::KeyEventHandler(this, &GUI::generalForm_KeyDown);
			this->KeyPress += gcnew System::Windows::Forms::KeyPressEventHandler(this, &GUI::generalForm_KeyPress);
			this->ResumeLayout(false);
			this->PerformLayout();

		}
#pragma endregion

	private:
		System::Void inputBox_KeyDown(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
			if (e->KeyCode == Keys::Enter) {
					String^ inputText = inputBox->Text;

					if (inputText == "exit") {
						MetroFramework::MetroMessageBox::Show(this, "Good Bye!", "Exiting the Application:", MessageBoxButtons::OK, MessageBoxIcon::Information);
						Application::Exit();
					} else if (inputText == "help") {
						getHelpText();
					} else if (inputText == "save") {
						OpenFileDialog^ filebrowser = gcnew OpenFileDialog;
						filebrowser->InitialDirectory = "c:\\";
						filebrowser->Filter = "txt files (*.txt)|*.txt";
						filebrowser->FilterIndex = 1;
						filebrowser->Multiselect = false;

						if (filebrowser->ShowDialog() == System::Windows::Forms::DialogResult::OK) {
							String^ filepath = filebrowser->FileName;

							Controller->processInput(inputText + " " + filepath);

							updateGUI();
						}
					} else {
						try {
							Controller->processInput(inputText);

							updateGUI();
						}
						catch (System::String^ errorMessage) {
							MetroFramework::MetroMessageBox::Show(this, errorMessage, "User Input Error:", MessageBoxButtons::OK, MessageBoxIcon::Error);
						}
					}

					inputBox->Clear();

					this->ActiveControl = FeedbackDisplay;

					e->Handled = true;
			}
			
			// Minimize via Ctrl + W
			else if (e->KeyData == (Keys::Control | Keys::W)) {
				if (WindowState == FormWindowState::Normal) {
					WindowState = FormWindowState::Minimized;
				}
				else {
					WindowState = FormWindowState::Normal;
				}
			}
			
			// Exit via Ctrl + Q
			else if (e->KeyData == (Keys::Control | Keys::Q)) {
				MetroFramework::MetroMessageBox::Show(this, "Good Bye!", "Exiting the Application:", MessageBoxButtons::OK, MessageBoxIcon::Information);
				Application::Exit();
			}

			// Undo via Ctrl + Z
			else if (e->KeyData == (Keys::Control | Keys::Z)) {
				Controller->processInput("undo");
			}

			// Move Cursor left or right on arrow keys
			else if (e->KeyData == Keys::Right) {
				inputBox->SelectionStart += 1;
			}
			else if (e->KeyData == Keys::Left) {
				if (inputBox->SelectionStart != 0) {
					inputBox->SelectionStart -= 1;
				}
			}

			e->Handled = true;
		}

	private:
```
###### Doowado GUI\GUI.h
``` h
		System::Void generalForm_KeyPress(System::Object^  sender, System::Windows::Forms::KeyPressEventArgs^  e) {
			if (e->KeyChar == (char)13 || e->KeyChar == (char)8) {
				this->ActiveControl = inputBox;
			}
			else {
				inputBox->Text = e->KeyChar.ToString();
				this->ActiveControl = inputBox;
				inputBox->SelectionStart = inputBox->Text->Length;
			}
		}

		System::Void updateGUI() {
			EventListDisplay->Items->Clear();
			getListofEvents();

			TaskListDisplay->Items->Clear();
			getListofTasks();

			getFeedbackList();
		}

		System::Void getListofEvents() {
			for (int i = 0; i < Controller->getEventListSize(); i++) {
				System::Windows::Forms::ListViewItem^ NewListViewItem;

				NewListViewItem = Controller->retrieveEventNameFromList(i);
				EventListDisplay->Items->Add(NewListViewItem);

				NewListViewItem = Controller->retrieveEventStartFromList(i);
				EventListDisplay->Items->Add(NewListViewItem);

				NewListViewItem = Controller->retrieveEventEndFromList(i);
				EventListDisplay->Items->Add(NewListViewItem);
			}
		}

		System::Void getListofTasks() {
			for (int i = 0; i < Controller->getTaskListSize(); i++) {
				System::Windows::Forms::ListViewItem^ NewListViewItem;

				NewListViewItem = Controller->retrieveTaskNameFromList(i);
				TaskListDisplay->Items->Add(NewListViewItem);

				NewListViewItem = Controller->retrieveTaskDueFromList(i);
				if (NewListViewItem->SubItems->Count > 1) {
					TaskListDisplay->Items->Add(NewListViewItem);
				}
			}
		}

		System::Void getFeedbackList() {
			FeedbackDisplay->AppendText("\r\n" + Controller->retrieveLastFeedback());

			EventListLabel->Text = Controller->retrieveEventListFeedback();
			TaskListLabel->Text = Controller->retrieveTaskListFeedback();
		}

		System::Void getHelpText() {
			HelpGUI^ HelpText = gcnew HelpGUI;
			HelpText->Show(this);
		}

	private:
		System::Void inputBox_TextChanged(System::Object^ sender, System::EventArgs^ e) {
			if (inputBox->Text == "add") {
				feedbackLabel->Text = "add <Entry name> from <start date/day> <start time> to <start date/day> <end time>";
			}
			else if (inputBox->Text == "edit") {
				feedbackLabel->Text = "edit <index> <new description> OR edit <index> start/end <new time>";
			}
			else if (inputBox->Text == "show") {
				feedbackLabel->Text = "show <date / day> OR show from <date> to <date>";
			}
			else if (inputBox->Text == "delete") {
				feedbackLabel->Text = "delete <index>";
			}
			else if (inputBox->Text == "undo") {
				feedbackLabel->Text = "undo";
			}
			else if (inputBox->Text == "search") {
				feedbackLabel->Text = "search <keyword 1> | <keyword 2> | <and so on>";
			}
			else if (inputBox->Text == "help") {
				feedbackLabel->Text = "help";
			}
			else if (inputBox->Text == "save") {
				feedbackLabel->Text = "save OR save <new save directory>";
			}
			else if (inputBox->Text == ""){
				feedbackLabel->Text = "add / edit / show / search / delete / undo / save / help";
			}
		}

	private: 
		System::Void inputBox_DoubleClick(System::Object^  sender, System::EventArgs^  e) {
			this->inputBox->Clear();
		}

	private: 
		System::Void inputBox_Enter(System::Object^  sender, System::EventArgs^  e) {
			this->inputBox->Clear();
		}
	
	private: 
		System::Void inputBox_Leave(System::Object^  sender, System::EventArgs^  e) {
			this->inputBox->Text = "Enter Command Here";
		}

	private: 
		System::Void timer1_Tick(System::Object^  sender, System::EventArgs^  e) {
			DateTime^ current = DateTime::Now;
			String^ date = current->Date.ToString("dddd, dd/MM/yyy");
			String^ time = current->ToString("hh : mm tt");

			this->dateLabel->Text = date;
			this->clockLabel->Text = time;
		}
};
}
```
