# A0114137R
###### Doowado - Task Manager\CmdBuilderException.cpp
``` cpp
 
CmdBuilderException::CmdBuilderException(std::string message)
{
	_message = message;
}

std::string CmdBuilderException::getMessage()
{
	return _message;
}


CmdBuilderException::~CmdBuilderException()
{
}
```
###### Doowado - Task Manager\CmdBuilderException.h
``` h

class CmdBuilderException
{
private:
	std::string _message;
public:
	CmdBuilderException(std::string message);
	std::string getMessage();
	~CmdBuilderException();
};

```
###### Doowado - Task Manager\Command.cpp
``` cpp

std::string Command::generateDateDisplayState(ptime entryStartTime, ptime entryEndTime)
{
	std::string displayState;

	if (entryStartTime.is_not_a_date_time()) {
		if (!entryEndTime.is_not_a_date_time()) {
			date endDate = entryEndTime.date();

			int endDay = endDate.day();
			int endMonth = endDate.month();
			int endYear = endDate.year();
			int intEndDayOfWeek = endDate.day_of_week();
			std::string endDayOfWeek;

			switch (intEndDayOfWeek)
			{
			case 0:
				endDayOfWeek = "Sun";
				break;
			case 1:
				endDayOfWeek = "Mon";
				break;
			case 2:
				endDayOfWeek = "Tue";
				break;
			case 3:
				endDayOfWeek = "Wed";
				break;
			case 4:
				endDayOfWeek = "Thu";
				break;
			case 5:
				endDayOfWeek = "Fri";
				break;
			case 6:
				endDayOfWeek = "Sat";
				break;
			default:
				break;
			}

			displayState = endDayOfWeek + ", " + to_string(endDay) + "/" + to_string(endMonth) + "/" + to_string(endYear);
		}
		else {
			displayState = "";
		}
	}
	else {
		if (!entryEndTime.is_not_a_date_time()) {
			date startDate = entryStartTime.date();

			int startDay = startDate.day();
			int startMonth = startDate.month();
			int startYear = startDate.year();
			int intStartDayOfWeek = startDate.day_of_week();

			std::string startDayOfWeek;

			switch (intStartDayOfWeek)
			{
			case 0:
				startDayOfWeek = "Sun";
				break;
			case 1:
				startDayOfWeek = "Mon";
				break;
			case 2:
				startDayOfWeek = "Tue";
				break;
			case 3:
				startDayOfWeek = "Wed";
				break;
			case 4:
				startDayOfWeek = "Thu";
				break;
			case 5:
				startDayOfWeek = "Fri";
				break;
			case 6:
				startDayOfWeek = "Sat";
				break;
			default:
				break;
			}

			displayState = startDayOfWeek + ", " + to_string(startDay) + "/" + to_string(startMonth) + "/" + to_string(startYear);
		
			date endDate = entryEndTime.date();

			int endDay = endDate.day();
			int endMonth = endDate.month();
			int endYear = endDate.year();
			int intEndDayOfWeek = endDate.day_of_week();
			std::string endDayOfWeek;

			switch (intEndDayOfWeek)
			{
			case 0:
				endDayOfWeek = "Sun";
				break;
			case 1:
				endDayOfWeek = "Mon";
				break;
			case 2:
				endDayOfWeek = "Tue";
				break;
			case 3:
				endDayOfWeek = "Wed";
				break;
			case 4:
				endDayOfWeek = "Thu";
				break;
			case 5:
				endDayOfWeek = "Fri";
				break;
			case 6:
				endDayOfWeek = "Sat";
				break;
			default:
				break;
			}

			displayState += "-" + endDayOfWeek + ", " + to_string(endDay) + "/" + to_string(endMonth) + "/" + to_string(endYear);
		}
		
	}

	return displayState;
}
```
###### Doowado - Task Manager\CommandBuilder.cpp
``` cpp

Command * CommandBuilder::createAddCommand(ParserResult& parserResult)
{
	Command * addCommand;
	string entryTitle;
	
	date entryStartDate;
	time_duration entryStartTime;
	date entryEndDate;
	time_duration entryEndTime;

	std::string stringStartDate;
	std::string stringStartTime;
	std::string stringEndDate;
	std::string stringEndTime;

	std::vector<std::string> description = parserResult.getDescription();
	std::vector<std::string> vStartDate = parserResult.getStartDate();
	std::vector<std::string> vStartTime = parserResult.getStartTime();
	std::vector<std::string> vEndDate = parserResult.getEndDate();
	std::vector<std::string> vEndTime = parserResult.getEndTime();

	if (description.empty()) {
		throw CmdBuilderException(EXCEPTION_NO_TITLE);
	}
	if (vStartDate.empty() && !vStartTime.empty()) {
		throw CmdBuilderException(EXCEPTION_TIME_NO_DATE);
	}
	if (vEndDate.empty() && !vEndTime.empty()) {
		throw CmdBuilderException(EXCEPTION_TIME_NO_DATE);
	}

	entryTitle = description[ZERO_INDEX];
	
	if (!vStartDate.empty()) {
		stringStartDate = vStartDate[ZERO_INDEX];
		date d(from_undelimited_string(stringStartDate));
		entryStartDate = d;
	}

	if (!vStartTime.empty()) {
		stringStartTime = vStartTime[ZERO_INDEX];
		time_duration td(duration_from_string(stringStartTime));
		entryStartTime = td;
	}

	if (!vEndDate.empty()) {
		stringEndDate = vEndDate[ZERO_INDEX];
		date d(from_undelimited_string(stringEndDate));
		entryEndDate = d;
	}

	if (!vEndTime.empty()) {
		stringEndTime = vEndTime[ZERO_INDEX];
		time_duration td(duration_from_string(stringEndTime));
		entryEndTime = td;
	}
	else {
		time_duration td(duration_from_string(STRING_END_TIME_INITIALISE));
		entryEndTime = td;
	}

	ptime entryStartPtime(entryStartDate, entryStartTime);
	ptime entryEndPtime(entryEndDate, entryEndTime);
/*
	if (!entryStartPtime.is_not_a_date_time() && !entryEndPtime.is_not_a_date_time()) {
		if (entryStartPtime > entryEndPtime) {
			LOG(INFO) << "CmdBuilderException startTime > endTime";
			LOG(INFO) << "CmdBuilderException startTime: " << entryStartPtime;
			LOG(INFO) << "CmdBuilderException endTime: " << entryEndPtime;
			throw CmdBuilderException(EXCEPTION_START_TIME_GREATER_END_TIME);
		}
	}
*/
	addCommand = new AddCommand(entryTitle, entryStartPtime, entryEndPtime);

	return addCommand;
}

Command * CommandBuilder::createEditCommand(ParserResult &parserResult)
{
	//exception for entry like edit 1 instead of T1
	Command* editCommand;
	
	EntryType entryType;
	int taskID =0;
	std::string newTitle = "";
	date newStartDate(not_a_date_time);
	time_duration newStartTime(not_a_date_time);
	date newEndDate(not_a_date_time);
	time_duration newEndTime(not_a_date_time);
	 
	std::vector<std::string> vEntryTypes = parserResult.getEntryType();
	
	if (vEntryTypes[ZERO_INDEX] == "e") {
		entryType = event;
	}
	else if (vEntryTypes[ZERO_INDEX] == "t") {
		entryType = task;
	}
	else {
		throw CmdBuilderException(EXCEPTION_INVALID_ENTRY_TYPE_AT_INDEX);
	}

	std::vector<int> vTaskIDs = parserResult.getIndex();
	if (vTaskIDs.empty()) {
		throw CmdBuilderException(EXCEPTION_INVALID_NO_INDEX);
	}

	taskID = vTaskIDs[ZERO_INDEX] - 1;

	std::vector<std::string> vNewTitles = parserResult.getDescription();
	
	if(!vNewTitles.empty()) {
		newTitle = vNewTitles[ZERO_INDEX];
	}
	
	std::vector<std::string> vNewStartDates = parserResult.getStartDate();
	
	if (!vNewStartDates.empty()) {
		std::string stringStartDate = vNewStartDates[ZERO_INDEX];
		if (stringStartDate == "null") {
			date d(neg_infin);
			newStartDate = d;
		}
		else {
			date d(from_undelimited_string(stringStartDate));
			newStartDate = d;
		}
	}

	std::vector<std::string> vNewStartTimes = parserResult.getStartTime();
	if (!vNewStartTimes.empty()) {
		std::string stringStartTime = vNewStartTimes[ZERO_INDEX];
		if (stringStartTime == "null") {
			time_duration td(neg_infin);
			newStartTime = td;
		}
		else {
			time_duration td(duration_from_string(stringStartTime));
			newStartTime = td;
		}
	}

	std::vector<std::string> vNewEndDates = parserResult.getEndDate();
	if (!vNewEndDates.empty()) {
		std::string stringEndDate = vNewEndDates[ZERO_INDEX];
		if (stringEndDate == "null") {
			date d(neg_infin);
			newEndDate = d;
		}
		else {
			date d(from_undelimited_string(stringEndDate));
			newEndDate = d;
		}
	}
	std::vector<std::string> vNewEndTimes = parserResult.getEndTime();
	if (!vNewEndTimes.empty()) {
		std::string stringEndTime = vNewEndTimes[ZERO_INDEX];
		if (stringEndTime == "null") {
			time_duration td(neg_infin);
			newEndTime = td;
		}
		else {
			time_duration td(duration_from_string(stringEndTime));
			newEndTime = td;
		}
	}

	if (vNewTitles.empty() && vNewStartDates.empty() && vNewStartTimes.empty() && vNewEndDates.empty() && vNewEndTimes.empty()) {
		throw CmdBuilderException(EXCEPTION_INVALID_EDIT);
	}

	LOG(INFO) << "CmdBuilder newStartDate: " << to_simple_string(newStartDate);
	LOG(INFO) << "CmdBuilder newStartTime: " << to_simple_string(newStartTime);
	LOG(INFO) << "CmdBuilder newEndDate: " << to_simple_string(newEndDate);
	LOG(INFO) << "CmdBuilder newEndTime: " << to_simple_string(newEndTime);

	editCommand = new EditCommand(entryType, taskID, newTitle, newStartDate, newStartTime, newEndDate, newEndTime);
	
	return editCommand;
}

Command * CommandBuilder::createDeleteCommand(ParserResult& parserResult)
{
	Command* deleteCommand;

	std::vector<std::string> vEntryTypes = parserResult.getEntryType();
	std::vector<int> vIndices = parserResult.getIndex();

	if (vEntryTypes.empty() || vIndices.empty()) {
		throw CmdBuilderException(EXCEPTION_INVALID_DELETE);
	}

	EntryType entryType;

	if (vEntryTypes[ZERO_INDEX] == "e") {
		entryType = event;
	}

	else if (vEntryTypes[ZERO_INDEX] == "t") {
		entryType = task;
	}
	
	else {
		throw CmdBuilderException(EXCEPTION_INVALID_ENTRY_TYPE_AT_INDEX);
	}

	int displayIndex = vIndices[ZERO_INDEX];

	int taskID = rebaseToZero(displayIndex);

	deleteCommand = new DeleteCommand(entryType, taskID);
	return deleteCommand;
}

Command * CommandBuilder::createSearchCommand(ParserResult& parserResult)
{
	//create SearchCommand;
	Command* searchCommand;
	
	std::vector<std::string> keywords = parserResult.getDescription();

	if (keywords.empty()) {
		throw CmdBuilderException(EXCEPTION_INVALID_SEARCH);
	}
	searchCommand = new SearchCommand(keywords);
	return searchCommand;
		
}

Command * CommandBuilder::createShowCommand(ParserResult& parserResult)
{
	//create ShowCommand;
	Command * showCommand = NULL;
	showType showType;

	date dateRequirement;
	std::string stringEntryStatus;

	std::string stringStartDate;
	std::string stringEndDate;
	
	std::vector<std::string> vStartDateRequirement = parserResult.getStartDate();
	std::vector<std::string> vEndDateRequirement = parserResult.getEndDate();
	std::vector<std::string> vEntryStatus = parserResult.getDescription();


	if (!vEntryStatus.empty()) {
		showType = showByStatus;
	}
	else if (!vStartDateRequirement.empty() && !vEndDateRequirement.empty()) {
		showType = showByRangeOfDate;
	}
	else if (!vEndDateRequirement.empty()) {
		showType = showByDate;
	}
	else {
		throw CmdBuilderException(EXCEPTION_INVALID_SHOW);
	}
	

	if (showType == showByStatus) {
		stringEntryStatus = vEntryStatus[ZERO_INDEX];

		if (stringEntryStatus == ENTRY_STATUS_COMPLETED) {
			showCommand = new ShowCommand(completed);
		}
		else if (stringEntryStatus == ENTRY_STATUS_INCOMPLETE) {
			showCommand = new ShowCommand(incomplete);
		}
		else if (stringEntryStatus == ENTRY_STATUS_OVERDUE) {
			showCommand = new ShowCommand(overdue);
		}
		else if (stringEntryStatus == ENTRY_STATUS_INTIME) {
			showCommand = new ShowCommand(intime);
		}
		else {
			throw CmdBuilderException(EXCEPTION_INVALID_SHOW_STATUS);
		}
	}
	
	else if (showType == showByDate) {
		stringEndDate = vEndDateRequirement[ZERO_INDEX];
		date endDate(from_undelimited_string(stringEndDate));
		if (endDate.is_not_a_date()) {
			throw CmdBuilderException(EXCEPTION_INVALID_TIME);
		}
		showCommand = new ShowCommand(endDate);
	}

	else if (showType == showByRangeOfDate) {
		stringStartDate = vStartDateRequirement[ZERO_INDEX];
		stringEndDate = vEndDateRequirement[ZERO_INDEX];
		date startDate(from_undelimited_string(stringStartDate));
		date endDate(from_undelimited_string(stringEndDate));
		
		if (startDate.is_not_a_date() || endDate.is_not_a_date()) {
			throw CmdBuilderException(EXCEPTION_INVALID_TIME);
		}
		showCommand = new ShowCommand(startDate, endDate);
	}

	return showCommand;
}

Command * CommandBuilder::createSaveCommand(ParserResult& parserResult)
{
	Command * saveCommand;
	std::vector<std::string> vSaveDirs;
	vSaveDirs = parserResult.getDescription();

	if (vSaveDirs.empty()) {
		throw CmdBuilderException(EXCEPTION_INVALID_SAVE);
	}
	std::string saveDir = vSaveDirs[ZERO_INDEX];
	saveCommand = new SaveCommand(saveDir);

	return saveCommand;
}

Command * CommandBuilder::createMarkDoneCommand(ParserResult &parserResult)
{
	Command* markDoneCommand;

	std::vector<std::string> vEntryTypes = parserResult.getEntryType();
	std::vector<int> vIndices = parserResult.getIndex();

	if (vEntryTypes.empty() || vIndices.empty()) {
		throw CmdBuilderException(EXCEPTION_INVALID_MARKDONE);
	}
	EntryType entryType;

	if (vEntryTypes[ZERO_INDEX] == "e") {
		entryType = event;
	}

	else if (vEntryTypes[ZERO_INDEX] == "t") {
		entryType = task;
	}
	else {
		throw CmdBuilderException(EXCEPTION_INVALID_ENTRY_TYPE_AT_INDEX);
	}

	int displayIndex = vIndices[ZERO_INDEX];
	int taskID = rebaseToZero(displayIndex);

	markDoneCommand = new MarkDoneCommand(entryType, taskID);
	return markDoneCommand;
}

Command * CommandBuilder::createUndoCommand(ParserResult & parserResult)
{
	Command * undoCommand;
	undoCommand = new UndoCommand();
	return undoCommand;
}

int CommandBuilder::rebaseToZero(int displayIndex)
{
	int rebasedInt = displayIndex - 1;
	return rebasedInt;
}

CommandBuilder::CommandBuilder() {

}

Command* CommandBuilder::buildCommand(ParserResult& parserResult) {
	Command *cmd = nullptr;

	std::string commandType = parserResult.getUserCommand();

	if (commandType == COMMANDTYPE_ADD) {
		cmd = createAddCommand(parserResult);
	}
	
	else if (commandType == COMMANDTYPE_EDIT) {
		cmd = createEditCommand(parserResult);
	}

	else if (commandType == COMMANDTYPE_DELETE) {
		cmd = createDeleteCommand(parserResult);
	}

	else if (commandType == COMMANDTYPE_SEARCH) {
		cmd = createSearchCommand(parserResult);
	}

	else if (commandType == COMMANDTYPE_SHOW) {
		cmd = createShowCommand(parserResult);
	}
	
	else if (commandType == COMMANDTYPE_SAVE) {
		cmd = createSaveCommand(parserResult);
	}
	else if (commandType == COMMANDTYPE_UNDO) {
		cmd = createUndoCommand(parserResult);
	}

	else if (commandType == COMMANDTYPE_MARK_DONE) {
		cmd = createMarkDoneCommand(parserResult);
	}
	else {
		throw CmdBuilderException(EXCEPTION_INVALID_COMMANDTYPE);
	}
	return cmd;
}

CommandBuilder::~CommandBuilder()
{
}

```
###### Doowado - Task Manager\CommandBuilder.h
``` h

#pragma once
#include<vector>
#include<assert.h>
#include<exception>
#include"Command.h"
#include"ParserResult.h"
#include"CmdBuilderException.h"
#include "easylogging++.h"

using namespace std;

const string COMMANDTYPE_ADD = "add";
const string COMMANDTYPE_EDIT = "edit";
const string COMMANDTYPE_DELETE = "delete";
const string COMMANDTYPE_SEARCH = "search";
const string COMMANDTYPE_SHOW = "show";
const string COMMANDTYPE_HELP = "help";
const string COMMANDTYPE_SAVE = "save";
const string COMMANDTYPE_MARK_DONE = "done";
const string COMMANDTYPE_UNDO = "undo";


class CommandBuilder {
	
	private:	
		Command* createAddCommand(ParserResult&);
		Command* createEditCommand(ParserResult&);
		Command* createDeleteCommand(ParserResult&);
		Command* createSearchCommand(ParserResult&);
		Command* createShowCommand(ParserResult&);
		Command* createSaveCommand(ParserResult&);
		Command* createMarkDoneCommand(ParserResult&);
		Command* createUndoCommand(ParserResult&);

		int rebaseToZero(int displayIndex);

	public:
		CommandBuilder();
		Command* buildCommand(ParserResult &);

		~CommandBuilder();
};            

```
###### Doowado - Task Manager\CommandException.cpp
``` cpp

CommandException::CommandException(std::string message)
{
	_message = message;
}

std::string CommandException::getMessage()
{
	return _message;
}


CommandException::~CommandException()
{
}
```
###### Doowado - Task Manager\CommandException.h
``` h

const std::string EXCEPTION_INDEX_OUT_OF_RANGE = "Invalid index: out-of-range.";
const std::string EXCEPTION_TIME_WITH_NO_DATE = "Invalid! Entry has time with no date.";
const std::string EXCEPTION_EVENT_NO_END_TIME = "Invalid! Your event must have an end date.";
const std::string EXCEPTION_INVALID_MARK_EVENT = "Invalid! Event cannot be marked as done.";

class CommandException
{
private:
	std::string _message;
public:
	CommandException(std::string message);
	std::string getMessage();
	~CommandException();
};

```
###### Doowado - Task Manager\DeleteCommand.cpp
``` cpp
void DeleteCommand::generateFeedback()
{
	_feedback.push_back(MESSAGE_SUCCESSFUL_DELETE);
	string entryTypeString;
	string indexString;
	string startTimeString;
	string endTimeString;
	string title;

	int displayIndex = _taskID + 1;
	indexString = to_string(displayIndex);

	if (_entryType == event) {
		entryTypeString = "E";
		title = _eventDeleted->getTitle();
		startTimeString = to_simple_string(_eventDeleted->getStartTime());
		endTimeString = to_simple_string(_eventDeleted->getEndTime());

		_feedback.push_back(entryTypeString + indexString);
		_feedback.push_back(title);
		_feedback.push_back(startTimeString);
		_feedback.push_back(endTimeString);
	}
	else if (_entryType == task) {
		entryTypeString = "T";
		title = _taskDeleted->getTitle();

		ptime endTime(_taskDeleted->getEndTime());
		if (!endTime.is_not_a_date_time()) {
			endTimeString = to_simple_string(_taskDeleted->getEndTime());
		}

		_feedback.push_back(entryTypeString + indexString);
		_feedback.push_back(title);
		_feedback.push_back(endTimeString);
	}
	
}

DeleteCommand::DeleteCommand(EntryType entryType, int displayIndex) {
	_entryType = entryType;
	_taskID = displayIndex;
}


DeleteCommand::~DeleteCommand()
{
}

EntryType DeleteCommand::getEntryType()
{
	return _entryType;
}

int DeleteCommand::getIndex()
{
	return _taskID;
}

void DeleteCommand::execute(Storage* data, Display* display) {
	//delete command
	if (_entryType == event) {
		if (_taskID < 0 || _taskID >= display->getEventList().size()) {
			throw CommandException(EXCEPTION_INDEX_OUT_OF_RANGE);
		}
	}
	else if (_entryType == task) {
		if (_taskID < 0 || _taskID >= display->getTaskList().size()) {
			throw CommandException(EXCEPTION_INDEX_OUT_OF_RANGE);
		}
	}

	Entry* entryToDelete = display->retrieveEntry(_entryType, _taskID);

	if (_entryType == event) {
		_eventDeleted = entryToDelete;
		data->deleteFromEventList(_eventDeleted);
		display->deleteEntry(_entryType, _taskID);
	}
	else if (_entryType == task) {
		_taskDeleted = entryToDelete;
		data->deleteFromTaskLIst(_taskDeleted);
		display->deleteEntry(_entryType, _taskID);
	}

	generateFeedback();
	display->updateCommandFeedback(_feedback);
	display->setLatestUpdatedEntry(NULL);
	History::pushCommand(this);
}

void DeleteCommand::undo(Storage * data, Display * display)
{
	restoreToStorage(data, display);
	generateUndoFeedback();
	updateDisplay(display, data);
}

void DeleteCommand::restoreToStorage(Storage* data, Display* display) {
	if (event == _entryType) {
		data->addEvent(_eventDeleted);
		display->setLatestUpdatedEntry(_eventDeleted);
	}
	else if (task == _entryType) {
		data->addTask(_taskDeleted);
		display->setLatestUpdatedEntry(_taskDeleted);
	}
}

void DeleteCommand::generateUndoFeedback()
{
	vector<string>::iterator front = _feedback.begin();

	_feedback.insert(front, "Undone");
}

void DeleteCommand::updateDisplay(Display* display, Storage* data)
{
	vector<Entry*> relevantEventList;
	vector<Entry*> relevantTaskList;
	ptime relevantTime;

	relevantTime = getRelevantTime(_entryType);
	data->retrieveByDate(relevantTime, relevantEventList, relevantTaskList);
	
	display->updateDisplayEventList(relevantEventList);
	display->updateDisplayTaskList(relevantTaskList);
	display->updateCommandFeedback(_feedback);
	if (_entryType == event) {
		display->setLatestUpdatedEntry(_eventDeleted);
	}
	else {
		display->setLatestUpdatedEntry(_taskDeleted);
	}

}

ptime DeleteCommand::getRelevantTime(EntryType _entryType) {
	
	ptime relevantTime;
	if (event == _entryType) {
		relevantTime = _eventDeleted->getStartTime();
	}
	else if (task == _entryType) {

		relevantTime = _taskDeleted->getEndTime();
		
		if (relevantTime.is_not_a_date_time()) {
			ptime currentTime(second_clock::local_time());
			relevantTime = currentTime;
		}
	}
	return relevantTime;
}
```
###### Doowado - Task Manager\DeleteCommand.h
``` h

const string MESSAGE_SUCCESSFUL_DELETE = "Deleted: ";

class DeleteCommand: public Command {
	private:
		EntryType _entryType;
		int _taskID;
		Entry* _eventDeleted;
		Entry* _taskDeleted;
		vector<string> _feedback;

		void generateFeedback();
		void generateUndoFeedback();

		void updateDisplay(Display *, Storage *);

		ptime getRelevantTime(EntryType _entryType);

	public:
		DeleteCommand(EntryType, int);
		~DeleteCommand();
		EntryType getEntryType();
		int getIndex();

		void execute(Storage* data, Display* display);
		void undo(Storage* data, Display* display);
		void restoreToStorage(Storage * storage, Display* display);
};

```
###### Doowado - Task Manager\Display.cpp
``` cpp

Entry * Display::retrieveEntry(EntryType entryType, int taskID)
{
	Entry* entryToRetrieve = nullptr;
	
	if (entryType == event) {
		if (taskID < _eventList.size()) {
			entryToRetrieve = _eventList[taskID];
		}
		else {
			entryToRetrieve = nullptr;
		}
	}
	else if (entryType == task) {
		if (taskID < _taskList.size()) {
			entryToRetrieve = _taskList[taskID];
		}
		else {
			entryToRetrieve = nullptr;
		}
	}
	return entryToRetrieve;
}

```
###### Doowado - Task Manager\Display.cpp
``` cpp

void Display::setEventDisplayState(string eventDisplayState)
{
	_eventDisplayState = eventDisplayState;
}

void Display::setTaskDisplayState(string taskDisplayState)
{
	_taskDisplayState = taskDisplayState;
}

string Display::getEventDisplayState()
{
	return _eventDisplayState;
}

string Display::getTaskDisplayState()
{
	return _taskDisplayState;
}

void Display::deleteEntry(EntryType entryType, int taskID)
{
	if (entryType == event) {
		_eventList.erase(_eventList.begin() + taskID);
	}
	else if (entryType == task) {
		_taskList.erase(_taskList.begin() + taskID);
	}
}

void Display::deleteEntry(Entry * entryToDelete)
{
	assert(entryToDelete != NULL);

	vector<Entry*>::iterator it = _eventList.begin();

	while (it != _eventList.end()) {
		if (*it == entryToDelete) {
			_eventList.erase(it);
			//LOG(INFO) << "Deleted from EventList for edit; " << (*it)->getTitle();
			break;
		}
		it++;
	}

	it = _taskList.begin();

	while (it != _taskList.end()) {
		if (*it == entryToDelete) {
			_taskList.erase(it);
			//LOG(INFO) << "Deleted from TaskList for edit; " << (*it)->getTitle();
			break;
		}
		it++;
	}

}

void Display::setLatestUpdatedEntry(Entry * latestEntry)
{
	_lastUpdatedEntry = latestEntry;
}

Entry * Display::retrieveLastUpdatedEntry(){
	return _lastUpdatedEntry;
}
```
###### Doowado - Task Manager\Display.h
``` h

	void setEventDisplayState(string eventDisplayState);
	void setTaskDisplayState(string taskDisplayState);
	string getEventDisplayState();
	string getTaskDisplayState();

	void deleteEntry(EntryType, int);
	void deleteEntry(Entry * entryToDelete);
	void setLatestUpdatedEntry(Entry * latestEntry);
	Entry* retrieveLastUpdatedEntry();
};

```
###### Doowado - Task Manager\EditCommand.cpp
``` cpp

void EditCommand::generateFeedback(Entry * editedEntry)
{
	_feedback.push_back(MESSAGE_SUCCESSFUL_EDIT);
	_feedback.push_back(editedEntry->getTitle());

	ptime startTime = editedEntry->getStartTime();
	ptime endTime = editedEntry->getEndTime();

	if (!startTime.is_not_a_date_time()) {
		_feedback.push_back(to_simple_string(startTime));
		_feedback.push_back(to_simple_string(endTime));
	}
	else if (!endTime.is_not_a_date_time()) {
		_feedback.push_back(to_simple_string(endTime));
	}
}

void EditCommand::generateUndoFeedBack(Entry * undoneEntry)
{
	_feedback.clear();
	_feedback.push_back(MESSAGE_SUCCESSFUL_UNDO);
}

void EditCommand::updateDisplay(Display * display, Storage * data, Entry * editedEntry)
{
	std::vector<Entry*> relevantEventList;
	std::vector<Entry*> relevantTaskList;
	
	ptime showTime;
	ptime startTime = editedEntry->getStartTime();
	ptime endTime = editedEntry->getEndTime();
	
	LOG(INFO) << "EditedEntry title:" << editedEntry->getTitle();
	LOG(INFO) << "EditedEntry startTime:" << startTime;
	LOG(INFO) << "EditedEntry endTime:" << endTime;

	if (!startTime.is_not_a_date_time()) {
		showTime = startTime;
		data->retrieveByDate(showTime, relevantEventList, relevantTaskList);
		display->updateDisplayEventList(relevantEventList);
		display->updateDisplayTaskList(relevantTaskList);
	}

	else if (!endTime.is_not_a_date_time()) {
		showTime = endTime;
		data->retrieveByDate(showTime, relevantEventList, relevantTaskList);
		display->updateDisplayEventList(relevantEventList);
		display->updateDisplayTaskList(relevantTaskList);
	}

	else if (editedEntry == _beforeEditEntry) {			//undo
			display->deleteEntry(_editedEntry);
			relevantTaskList = display->getTaskList();
			relevantTaskList.push_back(editedEntry);
			display->updateDisplayTaskList(relevantTaskList);
	}

	else if (editedEntry == _editedEntry) {
			display->deleteEntry(editedEntry);
			relevantTaskList = display->getTaskList();
			relevantTaskList.push_back(editedEntry);
			display->updateDisplayTaskList(relevantTaskList);
	}

	if (!startTime.is_not_a_date_time() || !endTime.is_not_a_date_time()) {
		std::string displayState = generateDateDisplayState(startTime, endTime);
		display->setEventDisplayState(displayState);
		display->setTaskDisplayState(displayState);
	}

	display->setLatestUpdatedEntry(editedEntry);
}

void EditCommand::setBeforeEditEntry(Entry * beforeEditEntry)
{
	string title = beforeEditEntry->getTitle();
	ptime startTime = beforeEditEntry->getStartTime();
	ptime endTime = beforeEditEntry->getEndTime();
	bool isDone = beforeEditEntry->isDone();
	bool isOverdue = beforeEditEntry->isOverdue();

	_beforeEditEntry = new Entry(title, startTime, endTime);
	_beforeEditEntry->setDone(isDone);
	_beforeEditEntry->setOverdue(isOverdue);
}

void EditCommand::setEditedEntry(Entry * editedEntry)
{
	_editedEntry = editedEntry;
}

TypeOfTimeEdit EditCommand::checkTimeEditStart()
{
	TypeOfTimeEdit editType;

	if (_newStartDate.is_neg_infinity() || _newStartTime.is_neg_infinity()) {
		editType = editNullStart;
	}
	else if (!_newStartDate.is_not_a_date()) {
		if (!_newStartTime.is_not_a_date_time()) {
			editType = editStartDateTime;
		}
		else {
			editType = editStartDate;
		}
	}
	else if(!_newStartTime.is_not_a_date_time()) {
		editType = editStartTime;
	}
	else {
		editType = noChangeinStart;
	}
	return editType;
}

TypeOfTimeEdit EditCommand::checkTimeEditEnd()
{
	TypeOfTimeEdit editType;

	if (_newEndDate.is_neg_infinity() || _newEndTime.is_neg_infinity()) {
		editType = editNullEnd;
	}
	else if (!_newEndDate.is_not_a_date()) {
		if (!_newEndTime.is_not_a_date_time()) {
			editType = editEndDateTime;
		}
		else {
			editType = editEndDate;
		}
	}
	else if (!_newEndTime.is_not_a_date_time()) {
		editType = editEndTime;
	}
	else {
		editType = noChangeinEnd;
	}
	return editType;
}

bool EditCommand::isOutOfRangeIndex(EntryType entryType, Display * display)
{
	if (_entryType == event) {
		if (_taskID < INDEX_LOWER_LIMIT || _taskID >= display->getEventList().size()) {
			return true;
		}
		else {
			return false;
		}
	}
	else if (_entryType == task) {
		if (_taskID < INDEX_LOWER_LIMIT || _taskID >= display->getTaskList().size()) {
			return true;
		}
		else {
			return false;
		}
	}
}

void EditCommand::processEditTimeEvent(Storage * data, Display * display, Entry * editedEntry, TypeOfTimeEdit typeEditStart, TypeOfTimeEdit typeEditEnd)
{
	//start time processing
	if (typeEditStart == editNullStart) {
		ptime editedStartTime(not_a_date_time);
		editedEntry->setStartTime(editedStartTime);
		data->addTask(editedEntry);
		data->deleteFromEventList(editedEntry); 
	}
	else if (typeEditStart == editStartDateTime) {
		date newStartDate(_newStartDate);
		time_duration newStartTime(_newStartTime);
		ptime editedStartTime(newStartDate, newStartTime);
		editedEntry->setStartTime(editedStartTime);
	}
	else if (typeEditStart == editStartDate) {
		date newStartDate(_newStartDate);
		time_duration originalStartTime = _beforeEditEntry->getStartTime().time_of_day();

		if (originalStartTime.is_not_a_date_time()) {
			ptime editedStartTime(newStartDate);
			editedEntry->setStartTime(editedStartTime);
		}
		else {
			ptime editedStartTime(newStartDate, originalStartTime);
			editedEntry->setStartTime(editedStartTime);
		}
	}

	else if (typeEditStart == editStartTime) {
		time_duration newStartTime(_newStartTime);
		date originalStartDate = _beforeEditEntry->getStartTime().date();

		if (originalStartDate.is_not_a_date()) {
			throw CommandException(EXCEPTION_TIME_WITH_NO_DATE);
		}
		else {
			ptime editedStartTime(originalStartDate, newStartTime);
			editedEntry->setStartTime(editedStartTime);
		}
	}

	else if (typeEditStart == noChangeinStart) {

	}


	//end time processing
	if (typeEditEnd == editNullEnd) {
		ptime editedEndTime(not_a_date_time);
		editedEntry->setEndTime(editedEndTime);
	}
	else if (typeEditEnd == editEndDateTime) {
		date newEndDate(_newEndDate);
		time_duration newEndTime(_newEndTime);
		ptime editedEndTime(newEndDate, newEndTime);
		editedEntry->setEndTime(editedEndTime);
	}
	else if (typeEditEnd == editEndDate) {
		date newEndDate(_newEndDate);
		time_duration originalEndTime = _beforeEditEntry->getEndTime().time_of_day();

		if (originalEndTime.is_not_a_date_time()) {
			time_duration newEndTime(duration_from_string(STRING_END_TIME_INITIALISE));
			ptime editedEndTime(newEndDate);
			editedEntry->setEndTime(editedEndTime);
		}
		else {
			ptime editedEndTime(newEndDate, originalEndTime);
			editedEntry->setEndTime(editedEndTime);
		}
	}

	else if (typeEditEnd == editEndTime) {
		time_duration newEndTime(_newEndTime);
		date originalEndDate = _beforeEditEntry->getEndTime().date();

		if (originalEndDate.is_not_a_date()) {
			throw CommandException(EXCEPTION_TIME_WITH_NO_DATE);
		}
		else {
			ptime editedEndTime(originalEndDate, newEndTime);
			editedEntry->setEndTime(editedEndTime);
		}
	}

	else if (typeEditEnd == noChangeinEnd) {
		
	}

	if (editedEntry->getEndTime().is_not_a_date_time() && !editedEntry->getStartTime().is_not_a_date_time()) {
		throw CommandException(EXCEPTION_EVENT_NO_END_TIME);
	}

}

void EditCommand::processEditTimeTask(Storage * data, Entry * editedEntry, TypeOfTimeEdit typeEditStart, TypeOfTimeEdit typeEditEnd)
{
	if (typeEditStart == editNullStart) {

	}

	else if (typeEditStart == editStartDateTime) {
		date newStartDate(_newStartDate);
		time_duration newStartTime(_newStartTime);
		ptime editedStartTime(newStartDate, newStartTime);
		editedEntry->setStartTime(editedStartTime);
		data->deleteFromTaskLIst(editedEntry);
		data->addEvent(editedEntry);
	}
	else if (typeEditStart == editStartDate) {
		date newStartDate(_newStartDate);
		time_duration originalStartTime = _beforeEditEntry->getStartTime().time_of_day();

		if (originalStartTime.is_not_a_date_time()) {
			ptime editedStartTime(newStartDate);
			editedEntry->setStartTime(editedStartTime);
		}
		else {
			ptime editedStartTime(newStartDate, originalStartTime);
			editedEntry->setStartTime(editedStartTime);
		}
	}

	else if (typeEditStart == editStartTime) {
		throw CommandException(EXCEPTION_TIME_WITH_NO_DATE);
	}
	else if (typeEditStart == noChangeinStart) {

	}

	//EndTime edit
	if (typeEditEnd == editNullEnd) {
		ptime editedEndTime(not_a_date_time);
		editedEntry->setEndTime(editedEndTime);
	}
	else if (typeEditEnd == editEndDateTime) {
		date newEndDate(_newEndDate);
		time_duration newEndTime(_newEndTime);
		ptime editedEndTime(newEndDate, newEndTime);
		editedEntry->setEndTime(editedEndTime);
	}
	else if (typeEditEnd == editEndDate) {
		date newEndDate(_newEndDate);
		time_duration originalEndTime = _beforeEditEntry->getEndTime().time_of_day();
		ptime editedEndTime;

		if (originalEndTime.is_not_a_date_time()) {
			time_duration newEndTime(duration_from_string(STRING_END_TIME_INITIALISE));
			ptime editedEndTime(newEndDate, newEndTime);
			editedEntry->setEndTime(editedEndTime);
		}
		else {
			ptime editedEndTime(newEndDate, originalEndTime);
			editedEntry->setEndTime(editedEndTime);
		}
	}

	else if (typeEditEnd == editEndTime) {
		time_duration newEndTime(_newEndTime);
		date originalEndDate = _beforeEditEntry->getEndTime().date();

		if (originalEndDate.is_not_a_date()) {
			throw CommandException(EXCEPTION_TIME_WITH_NO_DATE);
		}
		else {
			ptime editedEndTime(originalEndDate, newEndTime);
			editedEntry->setEndTime(editedEndTime);
		}
	}
	else if (typeEditEnd == noChangeinEnd) {

	}
	if (editedEntry->getEndTime().is_not_a_date_time() && !editedEntry->getStartTime().is_not_a_date_time()) {
		throw CommandException(EXCEPTION_EVENT_NO_END_TIME);
	}

}

bool EditCommand::isInvalidTime(Entry * editedEntry)
{
	ptime entryStartPtime(editedEntry->getStartTime());
	ptime entryEndPtime(editedEntry->getEndTime());

	if (!entryStartPtime.is_not_a_date_time() && !entryEndPtime.is_not_a_date_time()) {
		if (entryStartPtime > entryEndPtime) {
			return true;
		}
	}
	return false;
}

EditCommand::EditCommand(EntryType entryType, int taskID, string newTitle, date newStartDate, time_duration newStartTime, date newEndDate, time_duration newEndTime)
{
	_entryType = entryType;
	_taskID = taskID;
	_newTitle = newTitle;
	_newStartDate = newStartDate;
	_newStartTime = newStartTime;
	_newEndDate = newEndDate;
	_newEndTime = newEndTime;
	_beforeEditEntry = NULL;
}

EditCommand::~EditCommand()
{
}

void EditCommand::execute(Storage* data, Display *display)
{
	if (isOutOfRangeIndex(_entryType, display)) {
		throw CommandException(EXCEPTION_INDEX_OUT_OF_RANGE);
	}

	Entry* editedEntry = display->retrieveEntry(_entryType, _taskID);
	setBeforeEditEntry(editedEntry);

	if (_newTitle != "") {
		editedEntry->setTitle(_newTitle);
	}

	if (_entryType == event) {
		TypeOfTimeEdit typeEditStart = checkTimeEditStart();
		TypeOfTimeEdit typeEditEnd = checkTimeEditEnd();

		processEditTimeEvent(data, display, editedEntry, typeEditStart, typeEditEnd);
	} 

	else if (_entryType == task) {
		TypeOfTimeEdit typeEditStart = checkTimeEditStart();
		TypeOfTimeEdit typeEditEnd = checkTimeEditEnd();

		processEditTimeTask(data, editedEntry, typeEditStart, typeEditEnd);
	} 

	if (isInvalidTime(editedEntry)) {
		editedEntry->setStartTime(_beforeEditEntry->getStartTime());
		editedEntry->setEndTime(_beforeEditEntry->getEndTime());
		throw CommandException(EXCEPTION_START_TIME_GREATER_END_TIME);
	}
	
	setEditedEntry(editedEntry);
	generateFeedback(editedEntry);
	display->updateCommandFeedback(_feedback);
	updateDisplay(display, data, _editedEntry);
	data->saveToFile();

	History::pushCommand(this);

	return;
}

void EditCommand::undo(Storage * data, Display * display)
{
	string prevTitle = _beforeEditEntry->getTitle();
	ptime prevStartTime = _beforeEditEntry->getStartTime();
	ptime prevEndTime = _beforeEditEntry->getEndTime();
	bool prevIsCompleted = _beforeEditEntry->isDone();
	bool prevIsOverdue = _beforeEditEntry->isOverdue();

	if (_editedEntry->getTitle() != prevTitle) {
		_editedEntry->setTitle(prevTitle);
	}

	if (!_editedEntry->getStartTime().is_not_a_date_time() && prevStartTime.is_not_a_date_time()) {
		data->addTask(_beforeEditEntry);
		data->deleteFromEventList(_editedEntry);
	}
	else if (_editedEntry->getStartTime().is_not_a_date_time() && !prevStartTime.is_not_a_date_time()) {
		data->addEvent(_beforeEditEntry);
		data->deleteFromTaskLIst(_editedEntry);
	}

	generateUndoFeedBack(_beforeEditEntry);
	display->updateCommandFeedback(_feedback);
	updateDisplay(display, data, _beforeEditEntry);
	data->saveToFile();
}
```
###### Doowado - Task Manager\EditCommand.h
``` h

const int INDEX_LOWER_LIMIT = 0;
const std::string MESSAGE_SUCCESSFUL_EDIT = "Edited";
const std::string eventType = "e";
const std::string taskType = "t";

//check casing
enum TypeOfTimeEdit {	editStartDateTime,
						editStartDate,
						editStartTime,
						editNullStart,
						noChangeinStart,
						editEndDateTime,
						editEndDate,
						editEndTime,
						editNullEnd,
						noChangeinEnd
					};

class EditCommand : public Command
{
private:
	EntryType _entryType;
	int _taskID;
	std::string _newTitle;
	date _newStartDate;
	time_duration _newStartTime;
	date _newEndDate;
	time_duration _newEndTime;

	std::vector<std::string> _feedback;
	Entry * _beforeEditEntry;
	Entry * _editedEntry;

	void generateFeedback(Entry * editedEntry);
	void generateUndoFeedBack(Entry * undoneEntry);
	void updateDisplay(Display * display, Storage * storage, Entry * editedEntry);
	void setBeforeEditEntry(Entry * beforeEditEntry);
	void setEditedEntry(Entry * editedEntry);
	TypeOfTimeEdit checkTimeEditStart();
	TypeOfTimeEdit checkTimeEditEnd();
	bool isOutOfRangeIndex(EntryType entryType, Display * display);
	void processEditTimeEvent(Storage * data, Display * display, Entry * editedEntry, TypeOfTimeEdit typeEditStart, TypeOfTimeEdit typeEditEnd);
	void processEditTimeTask(Storage * data, Entry * editedEntry, TypeOfTimeEdit typeEditStart, TypeOfTimeEdit typeEditEnd);
	bool isInvalidTime(Entry * editedEntry);

public:
	EditCommand(EntryType entryType,
				int taskID,
				std::string newTitle,
				date newStartDate,
				time_duration newStartTime,
				date newEndDate,
				time_duration newEndTime);

	~EditCommand();
	void execute(Storage* data, Display* display);
	void undo(Storage* data, Display* display);
};

```
###### Doowado - Task Manager\Entry.cpp
``` cpp

Entry::Entry() {
	_title = "";
}

Entry::Entry(string title, ptime endTime)
{
	_title = title;
	_endTime = endTime;
	_isDone = false;
	_isClash = false;
	_isOverdue = false;
}

Entry::Entry(string title, ptime startTime, ptime endTime)
{
	_title = title;
	_startTime = startTime;
	_endTime = endTime;
	_isDone = false;
	_isClash = false;
	_isOverdue = false;
}

Entry::Entry(string title){
	_title = title;
	_isDone = false;
	_isClash = false;
	_isOverdue = false;
}

string Entry::getTitle(){
	return _title;
}

ptime Entry::getStartTime()
{
	return _startTime;
}

ptime Entry::getEndTime()
{
	return _endTime;
}

bool Entry::isDone()
{
	return _isDone;
}

bool Entry::isClash()
{
	return _isClash;
}

bool Entry::isOverdue()
{
	return _isOverdue;
}

void Entry::setTitle(string newTitle)
{
	_title = newTitle;
}

void Entry::setStartTime(ptime startTime)
{
	_startTime = startTime;
}

void Entry::setEndTime(ptime endTime)
{
	_endTime = endTime;
}

void Entry::setDone(bool doneStatus)
{
	_isDone = doneStatus;
}

void Entry::setClash(bool clashStatus)
{
	_isClash = clashStatus;
}

void Entry::setOverdue(bool overdueStatus)
{
	_isOverdue = overdueStatus;
}

```
###### Doowado - Task Manager\Entry.h
``` h

#include <string>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <iomanip>
#include <sstream>

using namespace std;
using namespace boost::gregorian;
using namespace boost::posix_time;

class Entry {
protected:
	string _title;
	ptime _startTime;
	ptime _endTime;
	bool _isDone;
	bool _isOverdue;
	bool _isClash;

public:
	Entry();
	Entry(string, ptime, ptime);
	Entry(string, ptime);
	Entry(string);
	string getTitle();
	ptime getStartTime();
	ptime getEndTime();
	bool isDone();
	bool isClash();
	bool isOverdue();

	void setTitle(string newTitle);
	void setStartTime(ptime);
	void setEndTime(ptime);
	void setDone(bool);
	void setClash(bool);
	void setOverdue(bool);

```
###### Doowado - Task Manager\Entry.h
``` h

	void printEvent();
	void printTask();
	string toStringEvent();
	string toStringTask();
};
```
###### Doowado - Task Manager\Logic.cpp
``` cpp

INITIALIZE_EASYLOGGINGPP;

void Logic::updateOverdueTask()
{
	std::vector<Entry*> taskList;
	taskList = _storage->retrieveTaskList();

	for (int i = 0; i < taskList.size(); i++) {
		ptime currTime(second_clock::local_time());

		if (currTime > taskList[i]->getEndTime() && !taskList[i]->isDone()) {
			taskList[i]->setOverdue(true);
		}
	}
}

void Logic::updateDoneEvent()
{
	std::vector<Entry*> eventList;
	eventList = _storage->retrieveEventList();

	for (int i = 0; i < eventList.size(); i++) {
		ptime currTime(second_clock::local_time());

		if (currentTime > eventList[i]->getEndTime()) {
			eventList[i]->setDone(true);
		}
	}
}

void Logic::updateClashEvent()
{
	std::vector<Entry*> eventList;
	eventList = _storage->retrieveEventList();

	for (int i = 0; i < eventList.size(); i++) {
		ptime eventStartTime1 = eventList[i]->getStartTime();
		ptime eventEndTime1 = eventList[i]->getEndTime();

		for (int j = i+1; j < eventList.size(); j++) {
			ptime eventStartTime2 = eventList[j]->getStartTime();
			ptime eventEndTime2 = eventList[j]->getEndTime();
			if (isOverlapTime(eventStartTime1, eventEndTime1, eventStartTime2, eventEndTime2)) {
				eventList[i]->setClash(true);
				eventList[j]->setClash(true);
			}
		}
	}
}

void Logic::updateNotClashingAnymore(){
	std::vector<Entry*> eventList;
	eventList = _storage->retrieveEventList();
	
	for (int i = 0; i < eventList.size(); i++) {
		if (eventList[i]->isClash()) {
			bool clashing = false;
			ptime eventStartTime1 = eventList[i]->getStartTime();
			ptime eventEndTime1 = eventList[i]->getEndTime();

			int j;

			for (j = 0; j < eventList.size() && !clashing; j++) {
				if (i != j) {
					ptime eventStartTime2 = eventList[j]->getStartTime();
					ptime eventEndTime2 = eventList[j]->getEndTime();

					if (isOverlapTime(eventStartTime1, eventEndTime1, eventStartTime2, eventEndTime2)) {
						clashing = true;
					}
				}
			}

			if (j == eventList.size()) {
				eventList[i]->setClash(clashing);
			}
		}
	}
}

bool Logic::isOverlapTime(ptime startTime1, ptime endTime1, ptime startTime2, ptime endTime2)
{
	bool isOverlap;

	if (startTime2 >= startTime1 && startTime2 <= endTime1) {
		isOverlap = true;
	}
	else if (endTime2 >= startTime1 && endTime2 <= endTime1) {
		isOverlap = true;
	}
	else {
		isOverlap = false;
	}
	return isOverlap;
}

Logic::Logic()
{
```
###### Doowado - Task Manager\Logic.h
``` h

#include "Storage.h"
#include "CommandBuilder.h"
#include "Command.h"
#include "Parser.h"
#include "Display.h"
#include "easylogging++.h"

static ptime currentTime(second_clock::local_time());

using namespace std;

class Logic
{
private:
	Storage* _storage;
	CommandBuilder* _cmdBuilder;
	Parser* _parser;
	Display* _display;
	void updateOverdueTask();
	void updateDoneEvent();
	void updateClashEvent();
	void updateNotClashingAnymore();
	bool isOverlapTime(ptime startTime1, ptime endTime1, ptime startTime2, ptime endTime2);

public:

#ifdef TESTMODE
	Storage* getStorage() {
		return _storage;
	}
#endif

	Logic();
	~Logic();
	void processCommand(string);
	void initialiseProgram();
	Display* getDisplay();
};

```
###### Doowado - Task Manager\MarkDoneCommand.cpp
``` cpp

void MarkDoneCommand::generateFeedback()
{
	_feedback.push_back(MESSAGE_SUCCESSFUL_MARK_DONE);
	
	std::string stringIndex;
	if (_entryType = event) {
		stringIndex += "E";
	}
	else if (_entryType = task) {
		stringIndex += "T";
	}
	
	stringIndex += to_string(_taskID + 1);
	_feedback.push_back(stringIndex);
}

MarkDoneCommand::MarkDoneCommand(EntryType entryType, int displayIdx)
{
	_entryType = entryType;
	_taskID = displayIdx;
}

MarkDoneCommand::~MarkDoneCommand()
{
}

EntryType MarkDoneCommand::getEntryType()
{
	return _entryType;
}

int MarkDoneCommand::getIndex()
{
	return _taskID;
}

Entry * MarkDoneCommand::getTaskMarkedDone()
{
	return _taskMarkedDone;
}

void MarkDoneCommand::execute(Storage * date, Display * display)
{
	if (_entryType == event) {
		if (_taskID < 0 || _taskID >= display->getEventList().size()) {
			throw CommandException(EXCEPTION_INDEX_OUT_OF_RANGE);
		}
	}
	else if (_entryType == task) {
		if (_taskID < 0 || _taskID >= display->getTaskList().size()) {
			throw CommandException(EXCEPTION_INDEX_OUT_OF_RANGE);
		}
	}

	Entry* entryToMarkDone = display->retrieveEntry(_entryType, _taskID);
	entryToMarkDone->setDone(true);

	if (_entryType == event) {
		throw CommandException(EXCEPTION_INVALID_MARK_EVENT);
	}
	else if (_entryType == task) {
		_taskMarkedDone = entryToMarkDone;
	}

	generateFeedback();
	display->updateCommandFeedback(_feedback);
	display->setLatestUpdatedEntry(_taskMarkedDone);
}
```
###### Doowado - Task Manager\MarkDoneCommand.h
``` h

const std::string MESSAGE_SUCCESSFUL_MARK_DONE = "Marked as done: ";

class MarkDoneCommand : public Command
{
private:
	EntryType _entryType;
	int _taskID;
	Entry* _taskMarkedDone;
	std::vector<std::string> _feedback;

	void generateFeedback();

public:
	MarkDoneCommand(EntryType, int);
	~MarkDoneCommand();

	EntryType getEntryType();
	int getIndex();
	Entry* getTaskMarkedDone();

	void execute(Storage*, Display*);
	//void undo(Storage * data, Display * display);

};

```
###### Doowado - Task Manager\SaveCommand.cpp
``` cpp

void SaveCommand::generateFeedback(bool isSuccessful)
{
	string feedback;
	if (isSuccessful) {
		feedback = MESSAGE_SUCCESSFUL_SAVE + _saveDir;
		_feedback.push_back(feedback);
	}
	else {
		feedback = MESSAGE_UNSUCCESSFUL_SAVE + _saveDir;
		_feedback.push_back(feedback);
	}
}

SaveCommand::SaveCommand(string saveDirectory)
{
	_saveDir = saveDirectory;
}


SaveCommand::~SaveCommand()
{
}

void SaveCommand::execute(Storage * data, Display * display)
{
	bool isSuccessful = true;
	data->changeSaveDirectory(_saveDir);
	
	generateFeedback(isSuccessful);

	display->updateCommandFeedback(_feedback);
	display->setLatestUpdatedEntry(NULL);
	data->saveToFile();
}
```
###### Doowado - Task Manager\SaveCommand.h
``` h

const string MESSAGE_SUCCESSFUL_SAVE = "File is successfully saved to ";
const string MESSAGE_UNSUCCESSFUL_SAVE = "Unsuccessful save to ";

class SaveCommand : public Command
{
private:
	string _saveDir;
	vector<string> _feedback;

	void generateFeedback(bool);

public:
	SaveCommand(string);
	~SaveCommand();
	void execute(Storage*, Display*);
};

```
###### Doowado - Task Manager\SearchCommand.cpp
``` cpp

void SearchCommand::generateFeedback()
{
	_feedback.push_back(MESSAGE_SUCCESSFUL_SEARCH_KEYWORDS);
	for (int i = 0; i < _keywords.size(); i++) {
		_feedback.push_back(_keywords[i]);
	}
}

string SearchCommand::generateDisplayState()
{
	string displayState;

	for (int i = 0; i < _keywords.size(); i++) {
		displayState += "\"" + _keywords[i] + "\"; ";
	}

	return displayState;
}

SearchCommand::SearchCommand(vector<string>& keywords)
{
	_keywords = keywords;
	int size = _keywords.size();
}


SearchCommand::~SearchCommand()
{
}

void SearchCommand::execute(Storage * data, Display * display)
{
	vector<Entry*> eventSearchResult;
	vector<Entry*> taskSearchResult;

	eventSearchResult = data->searchEventsByTitle(_keywords);
	taskSearchResult = data->searchTasksByTitle(_keywords);
	display->updateDisplayEventList(eventSearchResult);
	display->updateDisplayTaskList(taskSearchResult);

	generateFeedback();
	display->updateCommandFeedback(_feedback);

	string displayState = generateDisplayState();
	display->setEventDisplayState(displayState);
	display->setTaskDisplayState(displayState);
	display->setLatestUpdatedEntry(NULL);
}
```
###### Doowado - Task Manager\SearchCommand.h
``` h

const string MESSAGE_SUCCESSFUL_SEARCH_KEYWORDS = "Showing entries with keyword(s): ";

class SearchCommand : public Command
{
private:
	std::vector<std::string> _keywords;
	std::vector<std::string> _feedback;
	void generateFeedback();
	std::string generateDisplayState();

public:
	SearchCommand(std::vector<std::string>&);
	~SearchCommand();
	void execute(Storage* storage, Display* display);
};

```
###### Doowado - Task Manager\ShowCommand.cpp
``` cpp

std::string ShowCommand::generateStatusDisplayState()
{
	std::string taskDisplayState;

	if (_entryStatus == completed) {
		taskDisplayState = ENTRY_STATUS_COMPLETED;
	}
	else if (_entryStatus == incomplete) {
		taskDisplayState = ENTRY_STATUS_INCOMPLETE;
	}
	else if (_entryStatus == overdue) {
		taskDisplayState = ENTRY_STATUS_OVERDUE;
	}
	else if (_entryStatus == intime) {
		taskDisplayState = ENTRY_STATUS_INTIME;
	}

	return taskDisplayState;

}

void ShowCommand::generateDateFeedback()
{
	_feedback.push_back(MESSAGE_SUCCESSFUL_SHOW);
	if (!_requestedStartDate.is_not_a_date()) {
		_feedback.push_back(to_simple_string(_requestedStartDate));
	}
	_feedback.push_back(to_simple_string(_requestedEndDate));
}

void ShowCommand::generateStatusFeedback()
{
	_feedback.push_back(MESSAGE_SUCCESSFUL_SHOW);

	if (_entryStatus == completed) {
		_feedback.push_back(ENTRY_STATUS_COMPLETED);
	}
	else if (_entryStatus == incomplete) {
		_feedback.push_back(ENTRY_STATUS_INCOMPLETE);
	}
	else if (_entryStatus == overdue) {
		_feedback.push_back(ENTRY_STATUS_OVERDUE);
	}
	else if (_entryStatus == intime) {
		_feedback.push_back(ENTRY_STATUS_INTIME);
	}
}

ShowCommand::ShowCommand(date endDate)
{
	_requestedEndDate = endDate;
	_showType = showByDate;
}

ShowCommand::ShowCommand(date startDate, date endDate)
{
	_requestedStartDate = startDate;
	_requestedEndDate = endDate;
	_showType = showByRangeOfDate;
}

ShowCommand::ShowCommand(entryStatus status)
{
	_entryStatus = status;
	_showType = showByStatus;
}

ShowCommand::~ShowCommand()
{
}

void ShowCommand::execute(Storage * data, Display * display)
{
	std::string displayEventState;
	std::string displayTaskState;

	if (_showType == showByDate) {
		ptime ptimeStartDate;
		ptime ptimeEndDate(_requestedEndDate);
		data->retrieveByDate(ptimeEndDate, _requestedEventList, _requestedTaskList);
		display->updateDisplayEventList(_requestedEventList);
		display->updateDisplayTaskList(_requestedTaskList);
		generateDateFeedback();
		displayEventState = generateDateDisplayState(ptimeStartDate, ptimeEndDate);
		displayTaskState = generateDateDisplayState(ptimeStartDate, ptimeEndDate);
	}
	else if (_showType == showByRangeOfDate) {
		ptime ptimeStartDate(_requestedStartDate);
		ptime ptimeEndDate(_requestedEndDate);
		data->retrieveByDate(ptimeStartDate, ptimeEndDate, _requestedEventList, _requestedTaskList);
		display->updateDisplayEventList(_requestedEventList);
		display->updateDisplayTaskList(_requestedTaskList);
		generateDateFeedback();
		displayEventState = generateDateDisplayState(ptimeStartDate, ptimeEndDate);
		displayTaskState = generateDateDisplayState(ptimeStartDate, ptimeEndDate);
	}
	else if (_showType == showByStatus) {
		if (_entryStatus == completed) {
			_requestedTaskList = data->retrieveTaskByDone(true);
		}
		else if (_entryStatus == incomplete) {
			_requestedTaskList = data->retrieveTaskByDone(false);
		}
		else if (_entryStatus == overdue) {
			_requestedTaskList = data->retrieveTaskByOverdue(true);
		}
		else if (_entryStatus == intime) {
			_requestedTaskList = data->retrieveTaskByOverdue(false);
		}
		generateStatusFeedback();
		displayTaskState = generateStatusDisplayState();
		display->updateDisplayTaskList(_requestedTaskList);
	}

	display->updateCommandFeedback(_feedback);
	display->setEventDisplayState(displayEventState);
	display->setTaskDisplayState(displayTaskState);
	display->setLatestUpdatedEntry(NULL);
}
```
###### Doowado - Task Manager\ShowCommand.h
``` h

const string ENTRY_STATUS_COMPLETED = "completed";
const string ENTRY_STATUS_INCOMPLETE = "incomplete";
const string ENTRY_STATUS_OVERDUE = "overdue";
const string ENTRY_STATUS_INTIME = "intime";
const string MESSAGE_SUCCESSFUL_SHOW = "Showing: "; 

enum showType {showByDate, showByRangeOfDate, showByStatus};

class ShowCommand : public Command
{
#ifndef TESTMODE
private:
#else 
public: 
#endif
	std::vector<Entry*> _requestedEventList;
	std::vector<Entry*> _requestedTaskList;

	date _requestedStartDate;
	date _requestedEndDate;
	entryStatus _entryStatus;
	showType _showType;
	std::vector<std::string> _feedback;

	std::string generateStatusDisplayState();
	void generateDateFeedback();
	void generateStatusFeedback();


public:
	ShowCommand(date endDate);
	ShowCommand(date startDate, date endDate);
	ShowCommand(entryStatus status);
	~ShowCommand();

	void execute(Storage* data, Display* display);

};

```
